---
title: "try"
show-read-time: yes
tags:
  - Notes
  - COMP3331
color: 555555
comments: true
---
# COMP3331-Computer Networks and Applications

# Week1 - Introduction of Computer Networks (Part1)

---

## Introduction of Computer Networks (Part1)

### **What is the Internet?**

1. *An interconnection of different computer networks* 
    
    **"Nuts and bowl view"**
    
    - Billions of connected computing devices
        - hosts or end systems
    - Packet switches
        - forward packets (chunks of data)
        - include routers & switches
    - Communication links
        - transmission rate: bandwidth
        - fiber, copper, radio, satellite
    - Networks
        - collection of devices, routers, links: managed by an organization (e.g. ISP)
    - Internet
        - ‚Äúnetwork of networks‚Äù
    - protocols are everywhere
        - HTTP (Web), streaming video, Skype, TCP, IP, WiFi, 4G, Ethernet
        - control sending, receiving of messages
    - Internet standards
        - RFC: Request for Comments
        - IETF: Internet Engineering Task Force
2. *An infrastructure that provides services to networked applications also provides programming interface to distributed applications (API)*

### **What is a protocol?**

Protocols define the format, order of messages sent and received among network entities, and actions taken on msg transmission, receipt.

### **A closer look at Internet structure** (**Network edge & Network core)**

- **Network edge**
    
    *Access networks*, there are hosts (clients and servers) and physical media (wired, wireless communication links) 
    
    - DSL
        - digital subscriber line (DSL) use existing telephone line to central office DSLAM (DSL access multiplexer) to transmit data over DSL lines.
        - Different data rates for upload and download ‚Üí ADSL (Asymmetric digital subscriber lin)
        - distance factor affecting DSL speed (between the hub and home)
        - **dedicated** **access** to central office
        - ADSL speeds can vary depending on the distance to the exchange.
        - ADSL connections use the copper phone line to deliver internet
    - Cable
        - Cable uses frequency division multiplexing (FDM), in which different channels are transmitted in different frequency bands.
        - asymmetric downstream and upstream transmission rate.
        - homes **share access** network to cable headend
        - Cable internet connections are generally faster than ADSL connections.
        - Cable connections use coaxial cable to deliver internet and pay TV services to your home
    - Wireless access network
        - Wireless access network connects end system to router via base station aka ‚Äúaccess point‚Äù
        - WLANs ‚Üí Wireless local area networks
            - Spectrum is open (no permission needed)
        - Wide-area cellular access networks
            - restricted, so only certain companies can access
    - enterprise networks
        - companies, universities use mix of wired, wireless link technologies, connecting a mix of switches and routers to access network.
        
- **Network core**
    
    Mesh of interconnected routers and switches.
    
    There are two forms of switches networks:
    
    (When calculating the #users while using different switches, we assume all users are "active" while using circuit-switching and use the binomial distribution to get the probability of overload while using packet-switching since resources are allocated on demand, see example on slide p73)
    
    - packet-switching (Now)
        - hosts break application-layer messages into packets
        - **Is used in the Internet.**
        - forward packets from one router to the next, across links on path from source to destination
        - each packet transmitted at full link capacity
        - Data is sent as chunks of formatted bits (Packets), packets consist of a ‚Äúheader‚Äù and ‚Äúpayload‚Äù
            - payload is the data being carried
            - header holds instructions to the network for how to handle packet
        - Switches ‚Äúforward‚Äù packets based on their headers
            - "cut through" switch:
                
                the switch start transmit as soon as it has processed the header.
                
            - ‚Äústore and forward‚Äù switching:
                
                We will always assume a switch processes/forwards a packet after it has received it entirely.
                
        - Each packet travels independently
        - **No link resources are reserved**. Instead, packet switching leverages statistical multiplexing
            - In statistical multiplexing, data from multiple users (senders) is sent over a link. If one user does not use its share of the bandwidth, it is then free to be used by other users. Thus, senders share the link bandwidth, with no user having all of the link bandwidth allocated to it.
            - Statistical multiplexing relies on the assumption that not all flows burst at the same time (similar to insurance)
            
            <aside>
            üß∏ What do we do under overload?
             Queue overload into Buffer can deal with Transient Overload ,but can't solve persistent overload, Will eventually drop packets.
            
            </aside>
            
    - circuit-switching (Back to 60s)
        - **used in legacy telephone networks**.
        - end-end resources (part of bandwidth) allocated to, **reserved** for ‚Äúcall‚Äù between source and destination.
        - dedicated resources: no sharing
        - Frequency Division Multiplexing (FDM)
        - Time Division Multiplexing (TDM)
            
            <aside>
            üß∏ Why circuit switching is not feasible?
             1. **Inefficient**
            ‚Ä¢ Dedicated circuit cannot be used or shared in periods of
            silence
            ‚Ä¢ Cannot adapt to network dynamics
            2. **Fixed data rate**
            ‚Ä¢ Computers communicate at very diverse rates so fixed data rate is not useful.                                                                                                                                  
            3. **Connection state maintenance**
            ‚Ä¢ Requires per communication state to be maintained that
            is a considerable overhead
            ‚Ä¢ Not scalable
            
            </aside>
            

**So how the core of internet is structured?**

- Hosts connect to Internet via access Internet Service Providers (ISPs), which must be interconnected. So it is very complex.
- connect each access ISP to one global transit ISP
- ISPs connect via Internet Exchange Points (IXPs)
- Regional networks may arise to connect access nets to ISPs
- and content provider networks (e.g., Google, Microsoft, Akamai) may run their own network, to bring services, content close to end users.

### **Performance: loss, delay, throughput**

Occurs when packets queue in router buffers 

- **Packet delay**
    
    There are 4 resources.
    
    $$
    d_{nodal}=d_{proc}+d_{queue}+d_{trans}+d_{prop}
    
    $$
    
    - Processing delay
        - check bit errors
        - determine output link
        - **is not depend on the package size**, but can be effected by the packet size when the packet size is huge, this will indirectly cause increase the packet that we need to process, that will indirectly increase the time of processing.
    - Queuing delay
        - time waiting at output link for transmission
        - **is not depend on the packet size**, the queuing delay is the time that you need to wait for the router to wait for other users to process, so the queuing delay is depend on the number of packets on the router. (**It depends on network congestion**.)
        - aL/R is called traffic intensity (We want this much lower than 1)
            - aL bits arrive to queue per secf
            - R bits leave the router per sec
    - Transmission delay
        - **is depend on the packet size**, because the transmission delay is the time duration that we transmit the packet to the link, so it is equal to the packet size over bandwidth.
        - $d_{trans}=L/R$
        - L: packet length (bits)
        - R: link transmission rate (bps)
    - Propagation delay
        - **is not depend on the packet size**, because the propagation delay is equal to the physical distinction over the propagation speed (close to light speed), so the propagation delay is not related to the packet size.
        - $d_{prop}=d/s$
        - d: length of physical link
        - s: propagation speed (~$2 * 10^8$ m/sec)
    
    ### **`traceroute`**
    
    The program¬†`traceroute`¬†provides delay measurements from a source to a router along end-end Internet path towards destination.
    
    For all¬†i,¬†`traceroute`¬†will
    
    - Send three packets that will reach router¬†*i*¬†on path towards destination. (with time-to-live field value of i)
    - Router¬†*i*¬†will return packets to sender
    - Sender times interval between transmission and reply
- **Packet loss**
    - queue (aka buffer) preceding link in buffer has finite capacity
    - packet arriving to full queue dropped (aka lost).
    - Lost packet may be retransmitted by previous node, source end system, or not at all.
- **Throughput**
    - is the rate (bits/time unit) at which bits are being sent from sender S to receiver R.
    - bottleneck link: link on end-end path that **constrains** end-end throughput.
    - Usually,¬†bottleneck link is *S*¬†or¬†*R*.

# Week2 - Introduction of Computer Networks (Part2) & Introduction of Application Layer (Part1)

---

## Introduction of Computer Networks (Part2)

### **Protocol layers, Service models**

- **Internet protocol stack**
    - **Application**: Prepare data supporting network applications
        - FTP, SMTP, HTTP‚Ä¶
    - **Transport**: Ensure that packets get to the destination (process-process data transfer)
        - TCP, UDP
    - **Network**: Deliver packets across global network (routing of datagrams from source to destination)
        - IP, routing protocols
    - **Link**: Delivery packets within local network to next hop (data transfer between neighbouring network elements)
        - Ethernet, 802.111, PPP
    - **Physical**: Bits / Packets ‚Äòon the wire‚Äô
        - Fiber, Copper
    
    ![Screen Shot 2021-10-24 at 12.49.24 PM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-10-24_at_12.49.24_PM.png)
    
    1. Each layer depends on the layer below, supports the layer above and is independent. Each layer‚Äôs protocols have multiple versions (Components pick which lower-level protocol to use), except for IP in which there is one unifying protocol.
    2. The **benefit** of layering is that each layer provides a common abstraction for various network technologies. (so we don't have to reimplemented each new application for every network technology!)
    3. Some downsides of layering
        1. Layer N may duplicate lower-level functionality
            
            E.g., error recovery to retransmit lost data
            
        2. Information hiding may hurt performance
            
            E.g., packet loss due to corruption vs. congestion
            
        3. Headers start to get large
        E.g., typically, TCP + IP + Ethernet headers add up to 54 bytes
        4. Layer violations when the gains too great to resist
        E.g., Network Address Translation (NAT ‚Äì to be covered in Network Layer)
        5. Layer violations when network doesn‚Äôt trust ends
        E.g., Firewalls (Security)
    4. we need to implement layers across machines, so **what gets implemented where**?
        1. In **hosts**, every layer is required, 
        2. In **routers** only the network layer and below are required.
        3. In **switch**, only the link layer and below are required.
    5. Logical Communication and Physical Communication

## Introduction of Application Layer (Part1)

1. **principles of network applications**
    - **Client-server paradigm**
        - server:
            - always-on host
            - permanent IP address
            - often in data centers, for scaling
        - clients:
            - contact, communicate with server
            - may be intermittently connected
            - may have dynamic IP addresses
            - do not communicate directly with each other
            examples: HTTP, IMAP, FTP
    - **Peer-peer architecture (P2P)**
        - no always-on server
        - arbitrary end systems directly communicate
        - peers request service from other peers, provide service in return to other peers
        ‚Ä¢ self scalability ‚Äì new peers bring new service capacity, as well as new service demand.
        - peers are intermittently connected and change IP addresses
        ‚Ä¢ complex management
        - example: P2P file sharing, blockchain
    - **Processes communicating**
        
        process: program running within a host.
        
        - within same host, two processes communicate using inter-process communication(IPC) (defined by OS)
        - processes in different hosts communicate by exchanging messages
        - note: applications with P2P architectures have client processes & server processes
            - client process: process that initiates communication
            - server process: process that waits to be contacted
    - **Sockets**
        - Sockets allow processes to communicate even if they are on different machines.
        - To receive messages a process must have an¬†*identifier*¬†which includes both the IP address and port numbers associated with the process on the host machine.
    - **application-layer protocol**
    - **transport service that an app need**
        - data integrity
        - timing
        - throughput
        - security
    - **Internet transport protocols services**
        - **TCP service**
            - reliable transport between sending and receiving process
            - flow control: sender won‚Äôt overwhelm receiver
            - congestion control: throttle sender when network overloaded
            - does not provide: timing, minimum throughput guarantee, security
            - connection-oriented: setup required between client and server processes
        - **UDP service**
            - unreliable data transfer between sending and receiving process
            - does not provide: reliability, flow control, congestion control, timing, throughput guarantee, security, or connection setup.
            
            <aside>
            üß∏ **Why is there a UDP? When is it appropriate to use UDP instead of TCP?**
             In situations where you really want to get a simple answer to another server quickly, UDP works best. In general, you want the answer to be in one response packet, and you are prepared to implement your own protocol for reliability or to resend. DNS is the perfect description of this use case. The costs of connection setups are way too high (yet, DNS does support a TCP mode as well).
            Another case is when you are delivering data that can be lost because newer data coming in will replace that previous data/state. Weather data, video streaming, a stock quotation service (not used for actual trading), or gaming data comes to mind.
            Another case is when you are managing a tremendous amount of state and you want to avoid using TCP because the OS cannot handle that many sessions. This is a rare case today. In fact, there are now user-land TCP stacks that can be used so that the application writer may have finer grained control over the resources needed for that TCP state. Prior to 2003, UDP was really the only game in town.                                                                                                                                  
            One other case is for multicast traffic. UDP can be multicasted to multiple hosts whereas TCP cannot do this at all.
            (Cr [this](https://stackoverflow.com/questions/1099672/when-is-it-appropriate-to-use-udp-instead-of-tcp))
            
            </aside>
            

### **Web and HTTP**

- **Uniform Resource Locator (URL)**
    
    `protocol://host-name[:port]/directory-path/resource`
    
    - `protocol`: http, ftp, https, smtp etc
    - `host-name`: DNS name, IP address
    - `port`: defaults to protocol‚Äôs standard port; e.g. http: 80 https: 443
    - `directory-path`: hierarchical, reflecting file system
    - `resource`: identifies the desired resource
- **Hypertext Transfer Protocol (HTTP)**
    
    HTTP is the web‚Äôs application layer. It is based on a client/server architecture, uses TCP and is stateless.
    
    HTTP is all text, which makes the protocol simple to read, although is not the most efficient.
    
    - **HTTP Request**
        
        A HTTP request is made up of a request line and various header lines.
        
        > `GET /index.html HTTP/1.1\r\n
        Host: www-net.cs.umass.edu\r\n
        User-Agent: Firefox/3.6.10\r\n
        Accept: text/html,application/xhtml+xml\r\n 
        Accept-Language: en-us,en;q=0.5\r\n 
        Accept-Encoding: gzip,deflate\r\n 
        Accept-Charset: ISO-8859-1,utf-8;q=0.7\r\n 
        Keep-Alive: 115\r\n
        Connection: keep-alive\r\n
        \r\n`
        > 
    
    - **HTTP Response**
        
        A HTTP response is made up of a status line, various header lines and the data requested.
        
        > `HTTP/1.1 200 OK\r\n
        Date: Sun, 26 Sep 2010 20:09:20 GMT\r\n 
        Server: Apache/2.0.52 (CentOS)\r\n 
        Last-Modified: Tue, 30 Oct 2007 17:00:02 GMT\r\n
        ETag: "17dc6-a5c-bf716880"\r\n 
        Accept-Ranges: bytes\r\n
        Content-Length: 2652\r\n
        Keep-Alive: timeout=10, max=100\r\n 
        Connection: Keep-Alive\r\n
        Content-Type: text/html; charset=ISO-8859-1\r\n
        \r\n
        data data data data data ...`
        > 
        
    - **Status Codes**
        - Status code appears in first line in server-to-client response message. They indicate the status of the response.
        - For example
            - `200 OK`¬†status code means that the request succeeded
            - `404 Not Found`¬†status code means the resource was not found.
    - **Other HTTP request messages**
        
        `GET`,¬†`POST`,¬†`HEAD`,¬†`PUT`
        
    - **Cookies**
        - Web sites and client browser use cookies to maintain some state between transactions
        - But there are some dark sides of cookies, for example Third party cookies
    - **HTTP Performance**
        - Page Load Time (PLT) is an important metric
        - There are some goals(from different aspects like user, content provider, network)
        - So how to improve?
            - Reduce content size for transfer
            ‚Ä¢ Smaller images, compression
            - Change HTTP to make better use of available bandwidth
            ‚Ä¢ Persistent connections and pipelining
                - **HTTP/1.0**
                    - Non-persistent: **one TCP connection to fetch one web resource**
                        
                        ![Screen Shot 2021-10-23 at 5.12.44 PM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-10-23_at_5.12.44_PM.png)
                        
                    - Fairly poor PLT
                    - how to improve
                        - Parallel HTTP Connections (But here is a potential downside, which is Increase load on the server ‚Äì handling parallel TCP connections from multiple clients)
                            
                            ![Screen Shot 2021-10-23 at 5.13.14 PM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-10-23_at_5.13.14_PM.png)
                            
                        - **HTTP/1.1**
                            - **Persistent HTTP**
                                
                                server leaves TCP connection open after sending response
                                
                            - **Persistent without pipelining**
                                
                                one RTT for each referenced object
                                
                            - **Persistent with pipelining**
                                
                                as little as one RTT for all the referenced objects
                                
                                ![Screen Shot 2021-10-23 at 5.14.02 PM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-10-23_at_5.14.02_PM.png)
                                
                        
            - Change HTTP to avoid repeated transfers of the same content
            ‚Ä¢ Caching and web-proxies
                - **What is caching?**
                    
                    Caching is the process of storing copies of files in a cache, or temporary storage location, so that they can be accessed more quickly. 
                    
                - **Web caches (proxy servers)**
                    - **Why Web caching ?**
                        
                        The performance of web sites and applications can be significantly improved by reusing previously fetched resources. Web caches reduce latency and network traffic and thus lessen the time needed to display resource representations. HTTP caching makes Web sites more responsive.
                        
                    - Web cache acts as both client and server
                    - typically, cache is installed by ISP (university, company, residential ISP)
                    - Cache Check Request
                        - If-modified-since:<date>
                        - E-tag
            - Move content closer to the client
            ‚Ä¢ CDNs
                - What is CDN?
                    
                    A content delivery network (CDN) refers to a geographically distributed group of servers which work together to provide fast delivery of Internet content.
                    
                
                > Some useful articles about CDN and CDN catching
                > 
                > 
                > [https://www.cloudflare.com/en-au/learning/cdn/what-is-caching/](https://www.cloudflare.com/en-au/learning/cdn/what-is-caching/)
                > 
                > [https://www.cloudflare.com/en-au/learning/cdn/what-is-a-cdn/](https://www.cloudflare.com/en-au/learning/cdn/what-is-a-cdn/)
                > 
    
    - **HTTPs**
    - **HTTP/2**

### E**mail (SMTP)**

There are three major components: user agents, mail servers and simple mail transfer protocol (SMTP).

1. A¬†**user agent**¬†can be thought of as the mail client. It is responsible for composing, editing and reading mail messages.
2. A¬†**mail server**¬†is a mailbox containing incoming messages for a user, and a queue of outgoing messages.
3. The¬†**SMTP**¬†protocol is used between mail servers to send email messages.
    
    <aside>
    üß∏ Why do we have both Sender's and separate Receiver‚Äôs mail server?
    
    To ensure that the mail can be delivered if the receiver‚Äôs mail server is down momentarily and the recipient may not be always connected.
    
    </aside>
    
- **SMTP**
    - SMTP uses **TCP** to reliably transfer messages. It runs on port 25.
    - There are three phases of transfer:
        1. Handshaking
        2. Transfer of messages
        3. Closure
    - All SMTP messages must be in 7 bit ASCII.
    - command/response interaction (like HTTP)
    - SMTP uses persistent connections and uses¬†`CRLF.CRLF`¬†to determine the end of a message.
    - There are also other email protocols including¬†`POP`,¬†`IMAP`¬†and¬†`HTTP(S)`.

# Week3 - Introduction of Application Layer (Part2)

---

## Introduction of Application Layer (Part2)

### **DNS**

The Domain Name System (DNS) is the phonebook of the Internet. Humans access information online through¬†[domain names](https://www.cloudflare.com/learning/dns/glossary/what-is-a-domain-name/), like nytimes.com or espn.com. Web browsers interact through¬†[Internet Protocol (IP)](https://www.cloudflare.com/learning/network-layer/internet-protocol/)¬†addresses. **DNS translates domain names to¬†[IP addresses](https://www.cloudflare.com/learning/dns/glossary/what-is-my-ip-address/)¬†so browsers can load Internet resources**. (Cr [this](https://www.cloudflare.com/en-au/learning/dns/what-is-dns/))

[Domain Name System (DNS) is a distributed database implemented in a hierarchy of many name servers. Hosts and name servers communicate to resolve names.]

- DNS provides many services
    - Hostname to IP address translation
    - Host aliasing
    - Mail server aliasing
    - Load distribution
- **Hierarchy**
    
    DNS is a hierarchy of many name servers. At the top of the tree are the¬†**root**¬†name servers, which are distributed geographically around the world.
    
    - Hierarchical Namespace
        - Top level domain servers are under the root names servers
        - Domains are subtrees in a leaf-to-root path (Depth limit 128)
        - Each domain is responsible for its immediate level below
    - Hierarchical Administration
        - a distinct contiguous portion of the DNS name space that is managed by an administrative authority
    - Server Hierarchy
        - Top of hierarchy: Root servers
            - Location hardwired into other servers
            
            <aside>
            üß∏ **Why are there only 13 DNS root server addresses?**
            
            <aside>
            üß∏ A common misconception is that there are only 13 root servers in the world. In reality there are many more, but still only 13 IP addresses used to query the different root server networks. Limitations in the original architecture of DNS require there to be a maximum of 13 server addresses in the root zone. In the early days of the Internet, there was only one server for each of the 13 IP addresses, most of which were located in the United States.
            
            </aside>
            
            <aside>
            üß∏ Today each of the 13 IP addresses has several servers, which use [Anycast routing](https://www.cloudflare.com/learning/cdn/glossary/anycast-network/) to distribute requests based on load and proximity. Right now there are over 600 different DNS root servers distributed across every populated continent on earth.
            
            </aside>
            
            </aside>
            
        - Next Level: Top-level domain (TLD) servers
            - .com, .edu, etc. (several new TLDs introduced recently)
            - Managed professionally
            - A TLD name server maintains information for all the domain names that share a common domain extension, such as .com, .net, or whatever comes after the last dot in a url. For example, a .com TLD name server contains information for every website that ends in ‚Äò.com‚Äô.
        - Bottom Level: Authoritative DNS servers
            - Store the name-to-address mapping
            - Maintained by the corresponding administrative authority
            - When a recursive resolver receives a response from a TLD name server, that response will direct the resolver to an authoritative name server. The authoritative name server is usually the resolver‚Äôs last step in the journey for an IP address. The authoritative name server contains information specific to the domain name it serves (e.g. google.com) and it can provide a recursive resolver with the IP address of that server found in the¬†[DNS A record](https://www.cloudflare.com/learning/dns/dns-records/dns-a-record/), or if the domain has a¬†[CNAME record](https://www.cloudflare.com/learning/dns/dns-records/dns-cname-record/)¬†(alias) it will provide the recursive resolver with an alias domain, at which point the recursive resolver will have to perform a whole new DNS lookup to procure a record from an authoritative name server (often an A record containing an IP address).
        - **Local DNS Servers**
            - Local DNS name servers do not strictly belong to a hierarchy,
            - Each ISP has one (also called ‚Äúdefault name server‚Äù)
            - Hosts learn servers via a host configuration protocol. (e.g DHCP)
            - When a host makes a DNS query it is sent to its local DNS server which holds a cache of recent name-to-address translation pairs. The local server acts as a proxy that forwards the query into the hierarchy.
    - **DNS queries**
        - **Iterative query**¬†- in this situation the DNS client will allow a DNS server to return the best answer it can. If the queried DNS server does not have a match for the query name, it will return a referral to a DNS server authoritative for a lower level of the domain namespace. The DNS client will then make a query to the referral address. This process continues with additional DNS servers down the query chain until either an error or timeout occurs.
            
            ![Screen Shot 2021-10-23 at 7.38.47 PM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-10-23_at_7.38.47_PM.png)
            
        - **Recursive query**¬†- In a recursive query, a DNS client requires that a DNS server (typically a DNS recursive resolver) will respond to the client with either the requested resource record or an error message if the resolver can't find the record.
            
            ![Screen Shot 2021-10-23 at 7.40.32 PM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-10-23_at_7.40.32_PM.png)
            
            > useful articles:
            > 
            > 
            > [https://www.cloudflare.com/en-au/learning/dns/glossary/dns-root-server/](https://www.cloudflare.com/en-au/learning/dns/glossary/dns-root-server/)
            > 
            > [https://www.cloudflare.com/en-gb/learning/dns/dns-server-types/](https://www.cloudflare.com/en-gb/learning/dns/dns-server-types/)
            > 
    - **Caching, Updating DNS Records**
        - once (any) name server learns mapping, it caches mapping
            - cache entries timeout (disappear) after some time (TTL)
            - TLD servers typically cached in local name servers (thus root name servers not often visited)
        - cached entries may be out-of-date
            - The TTL field causes DNS servers to delete entries after some time, so that if the host moves and the underlying address changes, the server will eventually get the correct address.
    - **DNS Records**
        - A DNS database contains resource records (RR). The format of a RR is¬†`(name, value, type, ttl)`.
        - There are 4 types:
            - `A`
                - `name`¬†is the hostname
                - `value`¬†is the IP address
            - `CNAME`
                - `name`¬†is an alias for some canonical name (real name)
                - `value`¬†is the canonical name
            - `NS`
                - `name`¬†is the domain
                - `value`¬†is the hostname of the authoritative name server
            - `MX`
                - `value`¬†is the name of the mail server associated with¬†`name`
    - Reliability
        - DNS servers are replicated (primary/secondary)
            - Name service available if at least one replica is up
            - Queries can be load-balanced between replicas
        - Usually, **UDP used for queries**
            - [why DNS use UDP?](https://stackoverflow.com/questions/40063374/why-dns-uses-udp-as-the-transport-layer-protocol/40063445)
            - Need reliability: must implement this on top of UDP
            - Spec supports TCP too, but not always implemented
        - DNS uses port 53
        - Try alternate servers on timeout
            - Exponential backoff when retrying same server
        - Same identifier for all queries
            - Don‚Äôt care which server responds

### **P2P applications**

- What is P2P?
    
    In peer-to-peer (P2P) networking, a group of computers are linked together with equal permissions and responsibilities for processing data. Unlike traditional client-server networking, no devices in a P2P network are designated solely to serve or to receive data. Each connected machine has the same rights as its ‚Äúpeers‚Äù, and can be used for the same purposes.
    

![Screen Shot 2021-10-23 at 10.13.04 PM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-10-23_at_10.13.04_PM.png)

- P2P vs Client-Server
    - **P2P network** is a decentralised collection of computers that has been established to exchange information. But **client-server** model structure is a centralised network in which the server hosts, provides, and maintains the majority of the client‚Äôs data and services.
    - Usually, you can get 3-5 times faster on a peer-to-peer architecture than on client-server.
    - using P2P is not only faster, but also:
        - Provides significant savings on equipment and infrastructure
        - A more robust and resilient topology
    - But there are some downsides of p2p
- P2P file distribution: BitTorrent
    - What is torrent files?
        - The term ‚Äútorrent‚Äù refers to a file shared through a decentralised,¬†[peer-to-peer (P2P)](https://www.techslang.com/definition/what-is-peer-to-peer-p2p/)¬†sharing network. P2P file sharing allows users to exchange files without uploading these to a server. The term may also refer to the file name extension or metadata that tells trackers‚Äîprograms that coordinate the transfer of torrents‚Äîwhere to get torrent files.
    - How does torrent works?
        - A torrent file (.torrent) contains information telling users which computers are part of the file-sharing process. It may also provide some details on the files and folders that a user is downloading.
        - The torrent client connects to a tracker, which holds the IP addresses of the devices in a swarm. The tracker forwards the IP addresses to all torrent clients to ensure all peers are connected.
        - The torrent client starts the download. Once it receives sufficient bits of data, it also begins to upload the file for the benefit of other users.
    - **Requesting Chunks**
        
        At any given time, different peers have different subsets of file chunks. Peers request chunks from other peers in a¬†*rarest first*¬†order.
        
    - **Sending Chunks**
        - A peer¬†p¬†sends chunks to four other peers that are sending chunks at the highest rate to¬†p.
        - Every 30 seconds another peer is randomly selected to send chunks to, known as ‚Äòoptimistically unchock'.
    - **tit for tat**
        - BitTorrent uses tit-for-tat in each round to determine to which peers to upload chunks
        - BitTorrent selects the peers who have the best upload rate (in general). This ensures that chunks get uploaded faster, and they get replicated faster.
        - "tit-for-tat" selects these top four peers to upload chunks
        - Want to encourage all peers to contribute
        - Peer A said to *choke* peer B if it (A) decides not to upload to B
        - Each peer (say A) unchock at most 4 interested peers at any time
            - The three with the largest upload rates to A
                - Where the tit-for-tat comes in
            - Another randomly chosen (Optimistic unchock)
                - To periodically look for better choices
- **Distributed hash table (DHT)**
    - **What is DHT?**
        - A DHT is a distributed P2P database containing key value pairs representing tracker information. This removes the reliance on a centralised tracker.
        - a peer queries DHT with key, peers can also insert (key, value) pairs
        - Just like hash tables, DHTs support the following 2 functions:
            1. *put*¬†(key, value)
            2. *get*¬†(key)
    - **how to assign keys to peers?**
        - Consistent Hashing (DHT identifiers)
            - assign integer identifier to each peer in range [0,2n-1] for some n-bit hash function
            - require each key to be an integer in same range
            - to get integer key, hash original key
        - Assign keys to peers
            - rule: assign key to the peer that has the **closest** ID.
            - common convention: closest is the **immediate successor** of the key.
        - Put (key, value) pair in the peer that is closest to the key
            - Circular DHT with shortcuts
                - each peer keeps track of IP addresses of predecessor, successor, short cuts
                - possible to design shortcuts so O(log N) neighbours, O(log N) messages in query
            - Peer churn
                - peers may come and go (churn)
                - **each peer knows address of its two successors** (**also need to know its predecessor** but here we assumed it already knows)
                    - why a predecessor is required to be known to resolve peer churn?
                        - It is necessary for inserting a node and moving stored files when a node is being removed.
                - each peer periodically pings its two successors to check aliveness
                - if immediate successor leaves, choose next successor as new immediate successor
                - example:
                    
                    ![Screen Shot 2021-10-24 at 11.49.41 AM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-10-24_at_11.49.41_AM.png)
                    
                
                ![Screen Shot 2021-10-24 at 11.50.10 AM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-10-24_at_11.50.10_AM.png)
                

> useful articles or resources:
> 
> 
> [https://www.webroot.com/au/en/resources/glossary/what-is-peer-to-peer-networking](https://www.webroot.com/au/en/resources/glossary/what-is-peer-to-peer-networking)
> 
> [https://www.techslang.com/torrenting-what-is-it-and-how-does-it-work/](https://www.techslang.com/torrenting-what-is-it-and-how-does-it-work/)
> 
> [http://www.cs.cornell.edu/courses/cs5412/2012sp/slides/VI - Torrents and Tit for Tat.pdf](http://www.cs.cornell.edu/courses/cs5412/2012sp/slides/VI%20-%20Torrents%20and%20Tit%20for%20Tat.pdf)
> 

### **video streaming and content distribution networks (CDNs)**

- Multimedia: **video**
    - Def: sequence of images displayed at constant rate
    - CBR: (constant bit rate): video encoding rate fixed
    - VBR: (variable bit rate): video encoding rate changes as amount of spatial, temporal coding changes.
        - spatial coding example: instead of sending N values of same colour (all purple), send only two values: colour value (purple) and number of repeated values (N).
        - temporal coding example: instead of sending complete frame at i+1, send only differences from frame i.
- **Streaming** stored video
    - What is steaming?
        - Streaming is the continuous transmission of audio or video files from a server to a client. In simpler terms, streaming is what happens when consumers watch TV or listen to podcasts on Internet-connected devices. With streaming, the media file being played on the¬†[client device](https://www.cloudflare.com/learning/serverless/glossary/client-side-vs-server-side/)¬†is stored remotely, and is transmitted a few seconds at a time over the Internet.
    - challenges
        - continuous play-out constraint
            - need client-side buffering to match play-out requirements
                - compensate for network-added delay, delay jitter
        - client interactivity
        - video packets may be lost, retransmitted
    - **Streaming multimedia: DASH**
        - **Dynamic, Adaptive Streaming over HTTP (DASH)** is a streaming method.
        - Server:
            - Divides video files into multiple chunks
            - Each chunk is stored and encoded at different rates
            - A¬†*manifest file*¬†provides URLs for different chunks
        - Client:
            - Periodically measures server-to-client bandwidth
            - Consults the manifest and requests one chunk at a time based on current bandwidth
            - ‚Äúintelligence‚Äù at client:
                - Client determines¬†*when*¬†to request the chunk,¬†*what*¬†encoding rate to request and¬†*where*¬†to request the chunk from
        - **Streaming video = encoding + DASH + play-out buffering**
    - **CDNs**
        - To stream content to hundreds of thousands of simultaneous users, content distribution networks (CDNs) are used to store/serve multiple copies of videos at multiple geographically distributed sites
        - CDN: stores copies of content at CDN nodes
        - subscriber requests content from CDN
        - example:
            
            ![Screen Shot 2021-10-24 at 12.36.05 PM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-10-24_at_12.36.05_PM.png)
            

> useful articles or resources:
> 
> 
> [https://www.cloudflare.com/en-au/learning/video/what-is-streaming/](https://www.cloudflare.com/en-au/learning/video/what-is-streaming/)
> 
> [https://www.cloudflare.com/en-au/learning/video/what-is-mpeg-dash/](https://www.cloudflare.com/en-au/learning/video/what-is-mpeg-dash/)
> 

### **Socket Programming with UDP and TCP**

# Week4 - Introduction of Transport Layer (Part1)

---

## Introduction of Transport Layer (Part1)

### Transport-Layer Services

- Transport layer services and protocols provide logical communication between app processes running on different hosts.
- Transport protocols action in end systems where
    - The¬†*sender*¬†side breaks app messages into segments and passes them to network layer
    - The¬†*receiver*¬†side reassembles segments into messages and passes them to the application layer
- Two principal Internet transport protocols
    - TCP: Transmission Control Protocol
    ‚Ä¢ reliable, in-order delivery
    ‚Ä¢ congestion control
    ‚Ä¢ flow control
    ‚Ä¢ connection setup
        - E-mail and BitTorrent use TCP.
    - UDP: User Datagram Protocol
    ‚Ä¢ unreliable, unordered delivery
    ‚Ä¢ no-frills extension of ‚Äúbest-effort‚Äù IP
        - DNS and First Person Shooter Games typically use UDP.

### Multiplexing and Demultiplexing

- Multiplexing at sender:
    - Handles data from multiple sockets
    - Adds transport header (later used for demultiplexing)
- Demultiplexing at receiver:
    - Uses header information (IP addresses & port numbers) to deliver received segments to correct socket
    - **Connectionless Demultiplexing**
        - when creating datagram to send into UDP socket, must specify:
            - destination IP address
            - destination port #
        - When the host receives a UDP segment it checks
            - the destination port number in the segment
            - directs the segments to the socket with that port number.
        
        IP/UDP datagrams with **same destination port number**, but different source IP addresses and/or source port numbers will be directed to the **same socket at the destination.**
        
        Example:
        
        ![Screen Shot 2021-10-24 at 1.22.09 PM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-10-24_at_1.22.09_PM.png)
        
    - **Connection-oriented Demultiplexing**
        - A TCP socket is identified by a 4-tuple¬†`(sourceIP, sourcePort, destIP, destPort)`.
        - The receiver uses all four values to direct segments to appropriate sockets.
        - The server may support many simultaneous TCP sockets where each socket identified by its own 4-tuple and each socket associated with a different connecting client.
        - example:
            
            ![Screen Shot 2021-10-24 at 1.22.52 PM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-10-24_at_1.22.52_PM.png)
            
        
    - Summary
        - Multiplexing, demultiplexing: based on segment, datagram header field values
        - UDP: demultiplexing using destination port number (only)
        - TCP: demultiplexing using 4-tuple: source and destination IP addresses, and port numbers
        - Multiplexing/demultiplexing happen at all layers.

### Connectionless Transport: UDP

UDP is a ‚Äòbare bones‚Äô internet transfer protocol. During transport, UDP segments may get lost or may be delivered out of order. UDP is **connectionless**, meaning there is no handshaking between sender and receiver and that each UDP segment is handled independently of others.

<aside>
üß∏ Why is there a UDP?

<aside>
üß∏ 1. no connection establishment (which can add RTT delay)
2. simple: no connection state at sender, receiver
3. small header size (8 bytes)
4. no congestion control
   a. UDP can blast away as fast as desired!
   b. can function in the face of congestion

</aside>

</aside>

- A UDP segment header consists of
    - Source port number
    - Destination port number
    - Length (in bytes, including header)
    - Checksum (optional)
    - Payload
- **Checksum**
    - Goal: detect errors (i.e., flipped bits) in transmitted segment
    - Sender
        - Treats segment contents (including header fields and IP address), as a sequence of 16-bit integers.
        - Computes a **checksum** using addition (one‚Äôs complement sum) of segment contents
        - Puts the checksum value into the UDP checksum field
    - Receiver
        - Compute checksum of received segment
        - Check if computed checksum equals checksum field value.
- **Summary (UDP)**
    - ‚Äúno frills‚Äù protocol:
    ‚Ä¢ segments may be lost, delivered out of order
    ‚Ä¢ best effort service: ‚Äúsend and hope for the best‚Äù
    - UDP has its plusses:
    ‚Ä¢ no setup/handshaking needed (no RTT incurred)
    ‚Ä¢ can function when network service is compromised
    ‚Ä¢ helps with reliability (checksum)
    - build additional functionality on top of UDP in application layer
    (e.g., HTTP/3)

### Principles of Reliable Data Transfer (rdt)

- **RDT 1.0 - reliable transfer over a reliable channel**
    - In RDT 1.0, there is an underlying channel that is perfectly reliable, it has no bit errors and no loss of packets. The transport layer does nothing.

![Screen Shot 2021-10-24 at 1.46.52 PM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-10-24_at_1.46.52_PM.png)

- **RDT 2.0 - channel with bit errors**
    - In RDT 2.0, the underlying channel may flip bits in packets.
    - So how to recover from errors?
        - To recover from errors the receiver sends¬†**ACKs**, acknowledging that the packet was received ok, or receivers sends **NACKs**¬†to communicate that the packet had errors, then the packet will be retransmit by sender.
    - Compared to RDT 1.0
        - RDT 2.0 has¬†*error detection*,¬†*feedback*¬†via (N)ACKs and¬†*retransmission*.
    - Stop & Wait
        - sender sends one packet, then waits for receiver response
    
    ![Screen Shot 2021-10-24 at 1.54.06 PM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-10-24_at_1.54.06_PM.png)
    
    - RDT 2.0 has a **fatal flaw**!
        - If a (N)ACK is corrupted ‚Üí the sender doesn‚Äôt know what happened at receiver ‚Üí just retransmit the packet ‚Üí possible duplicate
        - handling duplicates
            - sender adds **sequence number** to each pkt
            - receiver discards (doesn‚Äôt deliver up) duplicate pkt
    
- **RDT 2.1**
    - Sender
        - In RDT 2.1, the sender adds a sequence number to the packet.
        - Two sequence numbers which are¬†`0`¬†and¬†`1` will suffice. (So the receiver will expect #0, #1, #0, ... Alternately)
        - The sender must also check if the (N)ACKs received are corrupted.  (use checksum)
    - Receiver
        - must check if a received packet is a duplicate using the packets sequence numbers.
        - receiver can not know if its last ACK/NAK received OK at sender
    - Compared to RDT 2.0
        - RDT 2.1 has¬†New Measures: *Sequence Numbers*, *Checksum for ACK/NACK*, *Duplicate detection*
    
    ![Screen Shot 2021-10-24 at 2.05.59 PM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-10-24_at_2.05.59_PM.png)
    
- **RDT 2.2 - a NAK-free protocol**
    - In RDT 2.2, the functionality is the same as RDT 2.1, except there are no NACK.
    - Instead of a NACK, the receiver sends an ACK for last packet received ok.
        - The receiver must explicitly include the sequence number of the packet being ACKed.
    - **A duplicate ACK at the sender results in the same action as NACK** - retransmit the packet.
    - As we will see, TCP uses this approach to be NAK-free
    
    ![Screen Shot 2021-10-24 at 2.12.13 PM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-10-24_at_2.12.13_PM.png)
    
- **RDT 3.0 - channels with errors and loss**
    - In RDT 3.0, we assume that the underlying channel can also lose packets, which means ACKs and data can be lost.
    - To combat this, the sender waits a ‚Äòreasonable‚Äô amount of time for the receivers ACK.
        - If no ACK is received in time, the sender retransmits the packet.
        - If the packet is just delayed, the retransmission will be a duplicate, but sequence numbers will handle this.
    - Compared to RDT 2.2
        - RDT 3.0 has¬†New Measures: *timeout*
    - Performance of RDT 3.0
        - rdt 3.0 protocol performance is very poor!
            - utilisation example
            
            ![Screen Shot 2021-10-24 at 2.26.34 PM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-10-24_at_2.26.34_PM.png)
            
        - Protocol limits performance of underlying infrastructure (channel)
        - Solution
            - pipelined protocols operation (See next billeted point)

![Screen Shot 2021-10-24 at 2.14.49 PM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-10-24_at_2.14.49_PM.png)

![Screen Shot 2021-10-24 at 2.15.24 PM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-10-24_at_2.15.24_PM.png)

- **Pipelined Protocols**
    - **Pipelining**¬†allows the sender to send multiple yet to be acknowledged packets.
        - To achieve this, the range of sequence numbers must be increased,
        - and there must be buffering at the sender and/or receiver.
    - There are two generic forms of pipelined protocols:¬†**go-back-N**¬†and¬†**selective repeat**.
    
    The utilisation¬†U¬†of the link when a pipelined protocol with window size¬†N¬†is used is given by
    
    $$
    U=N* \frac{L/R}{RTT + L/R}.
    $$
    
- **Go Back¬†N**
    - Sender:
        - The sender can have ‚Äúwindow‚Äù of up to N, consecutive transmitted but unACKed pkts.
            
            ![Screen Shot 2021-10-24 at 3.03.57 PM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-10-24_at_3.03.57_PM.png)
            
        - cumulative ACK: ACK(n): ACKs all packets up to, including seq # n
            - on receiving ACK(n): move window forward to begin at n+1
        - The sender has extra timer for the oldest unACKed packet, and when the timer expire, the sender will retransmit packet n and all higher seq# packets in window (See Pkt2 timer below in example)
        - There is no buffer available at the receiver and out of order packets are discarded
        - The receiver only sends a cumulative ACK and doesn‚Äôt ACK the new packet if there‚Äôs a gap
        - Sender window size¬†<2*n*¬†where¬†*n*¬†is the number of bits in the sequence number space < 2^n
    - Receiver:
        - ACK-only: always send ACK for correctly-received packet so far, with highest in-order seq #
            - may generate duplicate ACKs
            - need only remember rcv_base
        
        ![Screen Shot 2021-10-24 at 3.10.24 PM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-10-24_at_3.10.24_PM.png)
        
        - on receipt of out-of-order packet:
            - can discard (don‚Äôt buffer) or buffer: an implementation decision
            - re-ACK pkt with highest in-order seq #
    - Example
        
        ![Screen Shot 2021-10-24 at 3.13.15 PM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-10-24_at_3.13.15_PM.png)
        
- **Selective Repeat**
    - Sender:
        - The sender can have up to¬†*N*¬†unACKed packets in pipeline N
        - The sender maintains a timer for each unACKed packet, and when the timer expires, the sender will retransmit only that unACKed packet
        - Sender window size¬†‚â§1/2¬†of the sequence number space.
            - Why?
            - Example: seq # are 0, 1, 2, 3 (base 4 counting) & window size=3
                
                ![Screen Shot 2021-10-24 at 3.21.42 PM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-10-24_at_3.21.42_PM.png)
                
                (if window size = 2, it will be ok)
                
    - Receiver:
        - The receiver has a buffer and can accept out of order packets
        - The receiver sends an individual ACK for each packet
    - Example:
        
        ![Screen Shot 2021-10-24 at 3.19.35 PM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-10-24_at_3.19.35_PM.png)
        
        - Summary
            
            Checksums (for error detection)
            Timers (for loss detection)
            Acknowledgments (ACK)
              cumulative
              selective
            Sequence numbers (duplicates, windows)
            Sliding Windows (for efficiency)
            ‚Üí Reliability protocols use the above to decide when and what to retransmit or acknowledge
            

# Week5 - Introduction of Transport Layer (Part2)

---

### Connection-Oriented Transport: TCP

- **Segment Structure**
    - TCP Overview
        - Point to point
            - One sender, one receiver
        - Reliable, in order byte stream
            - no ‚Äúmessage boundaries"
        - Pipelined
            - TCP congestion and flow control set window size
        - Full duplex data
            - Bidirectional data flow in same connection
            - MSS: maximum segment size
        - cumulative ACKs
        - Connection oriented
            - Handshaking (exchange of control messages) initiates sender and receiver state before data exchange
        - Flow controlled
            - Sender will not overwhelm receiver
    - A TCP segment header consists of
        - Source port number
        - Destination port number
        - Sequence number
        - Acknowledgement number
        - Receive window
        - Header length
        - Checksum
        - Options
        - Data
    - TCP Maximum Segment Size (MSS)
        
        A TCP segment header is 20 bytes in size. An entire TCP segment is no more than the¬†**Maximum Segment Size**¬†(MSS).
        
        - IP packet
            - No bigger than Maximum Transmission Unit (MTU)
            - E.g., up to 1500 bytes with Ethernet
        - TCP packet
            - IP packet with a TCP header and data inside
            - TCP header  $\le$ 20 bytes long
        - TCP segment
            - No more than Maximum Segment Size (MSS) bytes
            - E.g., up to 1460 consecutive bytes from the stream
            - MSS = MTU ‚Äì 20 (min IP header ) ‚Äì 20 ( min TCP header )
- **Reliable data transfer**
    - What does TCP do?
        - **Checksum**
            - Computed over header and data (SAME AS UDP)
        - **Sequence Numbers & ACK Numbers**
            
            ![Screen Shot 2021-10-24 at 4.09.58 PM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-10-24_at_4.09.58_PM.png)
            
            - Why choose random ISN?
                - Potential security issue if the ISN is known
        - Receiver sends cumulative acknowledgements (like GBN)
            - Sender sends packet
                - Data starts with sequence number X
                - Packet contains B bytes [X, X+1, X+2, ‚Ä¶.X+B-1]
            - Upon receipt of packet, receiver sends an ACK
                - If all data prior to X already received:
                    - ACK acknowledges X+B (because that is next expected byte)
                    - Example
                    
                    ![Screen Shot 2021-10-24 at 4.35.00 PM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-10-24_at_4.35.00_PM.png)
                    
                - If highest in-order byte received is Y s.t. (Y+1) < X
                    - ACK acknowledges Y+1
                    - Even if this has been ACKed before
                    - Example
                        
                        ![Screen Shot 2021-10-24 at 4.35.34 PM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-10-24_at_4.35.34_PM.png)
                        
                
            - Piggybacking
                - In reality, usually both sides of a connection send some data.
                    
                    ![Screen Shot 2021-10-24 at 4.37.12 PM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-10-24_at_4.37.12_PM.png)
                    
        
        **Summary:**
        
        [next ack] = [pre seq] + [pre data]
        
        [next seq] = [pre ack]
        
        - **Receivers can buffer out-of-sequence packets (like SR)**
            
            Example:
            
            - Sender sends packets with 100 bytes and sequence numbers: 100, 200, 300, 400, 500, 600, 700, 800, 900, ‚Ä¶
            - Assume the fifth packet (seq. no. 500) is lost, but no others
            - 6th packet onwards are buffered
            - Stream of ACKs will be: 200, 300, 400, 500, 500, 500, 500,‚Ä¶
        - **Sender maintains a single retransmission timer (like GBN) and retransmits on timeout**
            - how to set TCP timeout value?
                - longer than RTT, but RTT varies!
            - **how to estimate RTT?**
                - **EstimatedRTT = (1- a)*EstimatedRTT + a*SampleRTT**
                - SampleRTT: measured time from segment transmission until ACK receipt(ignore retransmissions)
                - a = 0.125
            - timeout interval: EstimatedRTT + ‚Äúsafety margin‚Äù
                - large variation in EstimatedRTT: want a larger safety margin
                - TimeoutInterval = EstimatedRTT + 4*DevRTT
                - DevRTT: EWMA of SampleRTT deviation from EstimatedRTT
                    - exponential weighted moving average (EWMA)
                    - DevRTT = (1-b)*DevRTT + b*|SampleRTT-EstimatedRTT|
                    - b = 0.25
        - **Introduces fast retransmit: optimisation that uses duplicate ACKs to trigger early retransmission**
            - What is **fast retransmit**
                - if sender receives 3 additional ACKs for same data (‚Äútriple duplicate ACKs‚Äù), resend unACKed segment with smallest seq #
- **TCP flow control**
    - What is flow control?
        - receiver controls sender, so sender won‚Äôt overflow receiver‚Äôs buffer by transmitting too much, too fast.
    - TCP receiver ‚Äúadvertises‚Äù free buffer space in rwnd field (receiver window) in TCP header
- **Connection Management**
    - before exchanging data, sender/receiver ‚Äúhandshake‚Äù:
        - agree to establish connection (each knowing the other willing to establish connection)
        - agree on connection parameters (e.g., starting seq #s)
    - TCP 3-way handshake
        - is a process which is used in a TCP/IP network to make a connection between server and client
        - Packets:
            - `SYN` use to initiate and establish a connection
            - `ACK` helps to confirm to the other side that it has received the `SYN`.
            - `SYN-ACK` is a `SYN` message from local device and `ACK` of the earlier packet.
            - `FIN` is used for terminating a connection.
        - Process:
            - starting a connection
                - **A**¬†sends a¬†`SYN`¬†packet to tell¬†**B**¬†it wants to open a connection
                    - Starts from some ISN
                - **B**¬†sends a¬†`SYN-ACK`¬†packet to tell¬†**A**¬†it accepts and is ready to receive the next byte
                    - The¬†`SYN-ACK`¬†contains an ACK number with the value of¬†**A**‚Äôs ISN plus 1, and an ISN for¬†**B**
                - **A**¬†sends an¬†`ACK`¬†packet to¬†**B**¬†to acknowledge¬†**B**‚Äôs¬†`SYN-ACK`¬†packet
                    - The¬†`ACK`¬†contains an ACK number with the value of¬†**B**‚Äôs ISN plus 1, and a sequence number of¬†**A**‚Äôs ISN plus 1
            - Data is sent between¬†**A**¬†and¬†**B**
            - closing a connection
                - When finished,¬†**B**¬†sends a¬†`FIN`¬†packet to¬†**A**
                - **A**¬†sends an¬†`ACK`¬†packet to¬†**B**¬†with an ACK number of¬†**B**‚Äôs sequence number plus 1, and then a¬†`FIN`¬†packet to¬†**B**
                - **B**¬†sends an¬†`ACK`¬†packet to¬†**A**¬†with an ACK number of¬†**A**‚Äôs sequence number plus 1
        - Example
            
            ![Screen Shot 2021-10-24 at 5.57.41 PM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-10-24_at_5.57.41_PM.png)
            
        - Abrupt Termination
            - A sends a `RESET (RST)` to B
            - That means:
                - B does not ack the RST
                - Thus, RST is not delivered reliably
                - And: any data in flight is lost
                - But: if B sends anything more, will elicit another RST
        - TCP SYN Attack (SYN flooding)
        - TCP SYN Cookie
        
        <aside>
        üß∏ Question
        
        - **Why does a TCP sender use a very large retransmission timeout (e.g., several seconds) for the SYN segment?**
            - The TCP sender does not have any initial estimate of the round-trip time (RTT). Starting with a conservative retransmission timeout (RTO) of several seconds prevents the excessive retransmissions that would result from using an RTO that is smaller than the actual RTT.
        - **Why is it necessary to have a 3 way handshake for connection establishment in TCP? Why is a 2 way handshake not sufficient?**
            - TCP is a bi-directional communication protocol, which means either end ought to be able to send data reliably. Both parties need to establish an Initial Sequence Number (ISN), and both parties need to acknowledge the other's ISN. Thus a two-way handshake is required in each direction as follows: 1) Alice picks an ISN and SYNchronises it with Bob. 2) Bob ACKnowledges the ISN. 3) Bob picks an ISN and SYNchronises it with Alice. 4) Alice ACKnowledges the ISN. Steps 2 and 3 can be combined in a SYN-ACK segment, which reduces this to a 3 way handshake. A two way handshake would only allow one party to establish an ISN, and the other party to acknowledge it. Which means only one party can send data.
        </aside>
        

### Principles of Congestion Control

**Congestion**¬†informally is ‚Äútoo many sources sending too much data too fast for a network to handle‚Äù. It¬†*is different*¬†from flow control. As a result of congestion, packet loss and long delays can occur.

Congestion

- Increases delivery latency
- Increases loss rate
- Increases retransmissions, many unnecessary
- Increases congestion cycle continues...

There are two approaches to managing congestion

- **End-end congestion control**
    - No explicit feedback from network
    - Congestion is inferred from the end-system‚Äôs observed loss and delay
    - This is the approach taken with TCP
- **Network-assisted congestion control**
    - Routers provide feedback to end systems
    - (not really use, range of reasons like router shouldn‚Äôt work with tcp, since it's work in layer 3)

## TCP Congestion Control

A TCP connection has a¬†*window*¬†that controls the number of packets ‚Äòin flight‚Äô.

The TCP sending rate is

$$
rate \simeq \frac{cwnd}{RTT} \ \text{bytes/sec}
$$

where

- *cwnd*¬†is the Congestion Window
    - How many bytes can be sent without overflowing routers
    - Computed by the sender using congestion control algorithm
- *rwnd* is the Flow control window
    - How many bytes can be sent without overflowing receiver‚Äôs buffers
    - Determined by the receiver and reported to the sender

To control congestion, ***Vary window size to control sending rate***

**Sender-side window = minimum{CWND, RWND}**

So how does the sender detect congestion?

Duplicate ACKs ‚Üí isolated loss 

& Timeout ‚Üí Not enough dup ACK ‚Üí Must have suffered several losses ‚Üí smuch more serious

And how does the sender adjust its sending rate?

Basic structure is
Upon receipt of ACK (of new data) ‚Üí increase rate
Upon detection of loss ‚Üí decrease rate

### **TCP Slow Start**

When a TCP connection begins, we assume the value of¬†cwnd = 1*cwnd* = 1¬†MSS. Every time a transmitted segment is first acknowledged (i.e. every¬†*RTT*),¬†*cwnd*¬†is **doubled**. In the slow start phase, the sending rate is **increased exponentially** until the first loss is experienced. **The initial sending rate is slow, but increases rapidly.**

If there is a loss event indicated by a¬†*timeout*,¬†*cwnd*¬†is set back to 1 MSS, and the slow start phase starts again. A variable¬†*ssthresh*¬†is also set to¬†*cwnd*/2.

When the value of¬†*cwnd*¬†reaches¬†*ssthresh*, the slow start phase ends and the congestion avoidance phase begins.

**P.S. Recall MSS: Maximum Segment Size, the amount of payload data in a TCP packet here MSS only for convenience **[Keep in mind that real implementations maintain CWND in bytes]***

### **Congestion Avoidance**

On entry to the congestion avoidance phase, the value of¬†*cwnd*¬†is approximately half its value when congestion was last encountered. Now, rather than doubling the value of¬†*cwnd*¬†every¬†*RTT*, the value of¬†*cwnd*¬†only increases by 1 MSS.

The congestion avoidance phase behaves the same way as the slow start phase when a timeout occurs, that is it sets¬†*cwnd*¬†to 1 MSS and the value of¬†*ssthresh*¬†is set to *cwnd*/2.

> *In the case of a loss event indicated by a¬†triple duplicate ACK, the value of¬†cwnd¬†is halved and¬†ssthresh¬†is set to¬†cwnd/2. In this case, the congestion avoidance phase ends and the fast recovery phase begins.*
> 

> **Fast Recovery**
> 

> In fast recovery, the value of¬†cwnd*cwnd*¬†is increased by 1 MSS for every duplicate ACK received for the missing segment that caused TCP to enter the fast recovery phase. Eventually when an ACK arrives for the missing segment, TCP enters the congestion avoidance phase after deflating¬†*cwnd*.
> 

> If a timeout occurs, TCP enters the slow start phase,¬†cwnd*cwnd*¬†is set to 1 and the value of¬†ssthresh*ssthresh*¬†is set to¬†*cwnd*/2.
> 

### **Additive Increase Multiplicative Decrease (AIMD)**

In AIMD, the sender increases the transmission rate (window size), probing for usable bandwidth, until another congestion event occurs.

**Additive increase**¬†‚Üí increasing the¬†*cwnd*¬†by 1 MSS every¬†*RTT*¬†until a loss is detected.

$$
cwnd = cwnd + \frac{1}{cwnd} 
$$

**Multiplicative decrease**¬†‚Üí cut¬†*cwnd*¬†in half after a loss.

P.S. State at sender
‚Üí CWND (initialized to a small constant)
‚Üí slow start threshold‚Üí ssthresh (initialized to a large constant)

 When the *cwnd* = *ssthresh*, we convert to additive increase.

### **TCP Flavours**

- TCP Tahoe
    - *cwnd*=1¬†and enters slow start phase after either a timeout or triple duplicate ACK
- TCP Reno
    - *cwnd*=1¬†on timeout
    - *cwnd*=*cwnd*/2¬†on triple duplicate ACK
- TCP New Reno
    - TCP Reno + improved fast recovery(skipped)

# Week7 - Network Layer: Data Plane

---

> p.s. About Datagram (just differnent way calling packets)
> 

> transport layer ‚Üí segments
> 

> network layer ‚Üí datagrams
> 

## Overview of Network Layer

The network layer

- Transports segments from sending to receiving hosts
    - Sender ‚Üí encapsulates segments into datagrams passes to link layer
    - Receiver ‚Üí Delivers segments to the transport layer protocol
- Has network layer protocols in every host and router
- Routers
    - examine header fields in all IP datagrams passing through them
    - moves datagrams from input ports to output ports to transfer datagrams along end-end path
    

There are two key network layer functions

- **Forwarding**: moving packets from a router‚Äôs input link to appropriate router output link
    - A forwarding table is used to determine local forwarding at a given router, process of getting through single interchange
    - Forwarding = the actions taken by a router when a datagram arrives, the primary of this being deciding on which outgoing link it should be forwarded to by examining the forwarding table.  This constitutes the data plane.
- **Routing**: determining route taken by packets from source to destination
    - Routing algorithms are used to determine the end to end path through a network
    - Routing = an action that is global where routers exchange control messages with each other to find the "best" paths between source and destination nodes. There are specific algorithms executing in each router to achieve this. The routing algorithms once converged will populate the forwarding tables mentioned above. Routing constitutes the control plane.
    

### data plane

The¬†**data plane**¬†is a local, per router function that determines how a datagram arriving on router input port is forwarded to router output port (**Note that this port is completely different with socket's port what it's means is really just arriving at a router is forwarded to another router*)

### control plane

The¬†**control plane**¬†is network wide logic that determines how a datagram is routed among routers along an end to end path from source host to destination host. 

There are two control plane approaches; 

- traditional routing algorithms implemented in routers
    
    ![Screen Shot 2021-11-25 at 10.28.50 AM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-11-25_at_10.28.50_AM.png)
    
- software defined networking implemented in a centralised server. (SKIPPED)
    
    ![Screen Shot 2021-11-25 at 10.29.07 AM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-11-25_at_10.29.07_AM.png)
    

## IP: Internet Protocol

### datagram format

![Screen Shot 2021-11-25 at 10.49.29 AM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-11-25_at_10.49.29_AM.png)

- Version number (4 bits)
    - IP protocol version number
    - Typically, ‚Äú4‚Äù (for IPv4)
- Header length (4 bits)
    - Number of 32-bit words in the header
    - Can be more when IP options are used
- Total Length (16 bits)
    - Number of bytes in the packet ‚Üí header + payload
- Protocol (8 bits)
    - Identifies the higher-level protocol
    - Important for demultiplexing at receiving host

Checksum, TTL and Fragmentation Fields to prevent potential probelm

- 16-bit identifier (16 bits)
- Flags (3 bits)
    - Flags for fragmentation and reassembly
- Fragment offset (13 bits)
- TTL (8 bits)
    - Max number remaining hops
- Header checksum (16 bits)

- 32 bit source IP address (32 bits)
- 32 bit destination IP address (32 bits)
- Options (if any) (32 bits)
    - more header length mentioned above
- Payload (variable length, typically a TCP or UDP segment)

Potential probelm 

1. TTL‚Üíloops 
2. Header Corruption (Checksum)
    
    -Only computed over packet header, method is same as UDP/TCP checksum
    

 3.  Fragmentation

### **TTL**

Every packet being forwarded from router to router has a TTL. After each hop, this TTL is decremented, and if it reaches 0 then the packet is discarded and a ‚Äòtime exceeded‚Äô message is sent to the source. This mechanism helps to *prevent loops* in a network.

### Fragmentation

Network links have a maximum transfer unit (MTU) size which represents the largest possible link-level frame. A large IP datagram is divided, or¬†*fragmented*, with the network if it is larger than the MTU. One datagram becomes several, and the IP header bits are used to reassembled it at the destination.

- **Example:**

An example is given below with a 4000 byte datagram (`Packet`) and a MTU of 1500 bytes. The datagram is split into three smaller datagrams (`P1`,¬†`P2`,¬†`P3`).

![Screen Shot 2021-11-25 at 11.20.49 AM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-11-25_at_11.20.49_AM.png)

- The IPv4 fragmentation **procedure** is as follows
    
    **Fragmentation**
    
    1. Router breaks up datagram in sizes that the output link can support
    2. Router copies IP header to pieces
    3. Router adjusts length of pieces
    4. Router sets offset of pieces to indicate position
    5. Router sets¬†`MF flag=1`¬†on all pieces except the last to indate ‚Äúmore fragments‚Äù
    6. Router re-computes the checksum
    
    **Re-assembly**
    
    The receiving host uses the¬†`Id`¬†field with the¬†`MF flag`¬†field and offset to reassemble the datagram
    
    Fragmentation of fragments is also supported.
    
    ![Screen Shot 2021-11-25 at 11.19.36 AM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-11-25_at_11.19.36_AM.png)
    
- **Path MTU Discovery**
    - Host
        - Sends a large packet to test whether all routers in path to the destination can support it or not
        - Sets¬†`DF`¬†(do not fragment) flag
    - Routers
        - Drops the packet if it is too large
        - Provides feedback to the host with an ICMP message telling them the MTU
- **Special Handling (SKIPPED)**
    - ‚ÄúType of Service‚Äù, or ‚ÄúDifferentiated Services Code Point (DSCP)‚Äù (8 bits)
    - Options (not often used)

### IPv4 addressing

An¬†**IP address**¬†is a 32 bit identifier for hosts and router interfaces. An¬†**interface**¬†is a connection between a host/router and a physical link. Each interface has an associated IP address.

- **Subnets**
    - device interfaces that can physically reach each other without passing through an intervening router
    - IP addresses have structure:
        - **subnet part**: devices in same subnet have common high order bits
        - **host part**: remaining low order bits
    - Example
        
        ![Screen Shot 2021-11-25 at 12.00.44 PM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-11-25_at_12.00.44_PM.png)
        
- **Network Mask**
    - A mask is used in conjunction with the network address to indicate how many higher order bits are used for the network part of the address. A bitwise AND is performed on the IP address and mask.
    - A¬†**broadcast address**¬†an address where the host part is all 1‚Äôs, i.e.¬†`223.1.1.255`. A¬†**network address**¬†is an address where the host part is all 0‚Äôs, i.e.¬†`223.1.1.0`. Both of these addresses are not assigned to any host.
    
- **Classes**
    - If the first bit is a 0
        - The address belongs to class A
    - Else if the second bit is a 0
        - The address belongs to class B
    - Else if the third bit is a 0
        - The address belongs to class C
    - Else if the fourth bit is a 0 (SKIPPED)
        - The address belongs to class D
        - Else (SKIPPED)
            - The address belongs to class E

- **Subnetting**
    - Subnetting is the process of dividing the class A, B or C networks into more manageable chunks that are suited to a network‚Äôs size and structure.
    - Subnetting allows 3 levels of hierarchy, netid, subnetid and hostid.
    - The original netid remains the same and designates the site.
    - Subnetting remains transparent outside of the site.
    - The process of subnetting simply extends the point where the 1‚Äôs of the mask stop and 0‚Äôs start. Some host ID bits are sacrificed to gain network ID bits.
    - example:
        
        ![Screen Shot 2021-11-25 at 12.08.33 PM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-11-25_at_12.08.33_PM.png)
        
        ![Screen Shot 2021-11-25 at 12.08.52 PM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-11-25_at_12.08.52_PM.png)
        
        - more example:
            
            ![Screen Shot 2021-11-25 at 12.10.09 PM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-11-25_at_12.10.09_PM.png)
            
            ![Screen Shot 2021-11-25 at 12.10.26 PM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-11-25_at_12.10.26_PM.png)
            
            ![Screen Shot 2021-11-25 at 12.10.44 PM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-11-25_at_12.10.44_PM.png)
            
            ![Screen Shot 2021-11-25 at 12.11.07 PM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-11-25_at_12.11.07_PM.png)
            
- **Today‚Äôs addressing: CIDR**
    - CIDR: Classless InterDomain Routing
    - address format: a.b.c.d/x, where x is #bits in network portion of address
    - example:
        
        ![Screen Shot 2021-11-25 at 12.08.01 PM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-11-25_at_12.08.01_PM.png)
        

How does host get IP address?

- **DHCP**
    - Dynamic Host Configuration Protocol
    - DHCP allows hosts to dynamically obtain its IP address from a network server when it joins a network. The host can renew its lease on an address in use.
    - The process of obtaining an IP address with DHCP is
        - The host broadcasts a ‚ÄúDHCP discover‚Äù message
        - The DHCP server responds with a ‚ÄúDHCP offer‚Äù message
        - The host requests an IP address with a ‚ÄúDHCP request‚Äù message
        - The DHCP server sends an address with a ‚ÄúDHCP ack‚Äù message
            
            ![Screen Shot 2021-11-25 at 12.33.41 PM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-11-25_at_12.33.41_PM.png)
            
- **Hierarchical addressing**
    - hierarchical addressing allows efficient advertisement of routing information
        
        ![Screen Shot 2021-11-25 at 12.36.02 PM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-11-25_at_12.36.02_PM.png)
        
    
- **Longest Prefix Matching**
    - When looking for a forwarding table entry for a given destination address, use the longest address prefix that matches the destination address.

### Network address translation

A NAT router must

- Replace the source IP address and port number of every outgoing datagram with the NAT IP address and a new port number
- Remember, in a NAT translation table, every(source IP, port #) to (NAT IP address, new port #)translation pair
- replace (NAT IP address, new port #) in destination fields of every incoming datagram with corresponding (source IP address, port #) stored in NAT table
- example:
    
    ![Screen Shot 2021-11-25 at 1.07.19 PM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-11-25_at_1.07.19_PM.png)
    

### IPv6

The initial motiviation to introduce IPv6 addressing was that the 32 bit IPv4 address space is soon to be complete allocated.

The IPv6 datagram format has a fixed length 40 byte header, and no fragmentation is allowed. In IPv6, the checksum in the head is completely removed to reduce processing time at each hop.

![Screen Shot 2021-11-25 at 1.27.12 PM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-11-25_at_1.27.12_PM.png)

how will network operate with mixed IPv4 and IPv6 routers?

- Tunneling ‚Üí IPv6 datagram carried as payload in IPv4 datagram among IPv4 routers (‚Äúpacket within a packet‚Äù)
    
    ![Screen Shot 2021-11-25 at 1.29.39 PM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-11-25_at_1.29.39_PM.png)
    

# Week8 - Control Plane (Routing)

---

## Routing protocols

- Goal
    
    determine ‚Äúgood‚Äù(least ‚Äúcost‚Äù, ‚Äúfastest‚Äù, ‚Äúleast congested‚Äù) paths (equivalently, routes), from sending hosts to receiving host, through network of routers
    
- Internet Routing
    - intra-domain
        - Each AS(Autonomous System, aka. domain) runs an intra-domain routing protocol that establishes routes **within its domain**
        - Link State, e.g., Open Shortest Path First (OSPF)
        - Distance Vector, e.g., Routing Information Protocol (RIP)
    - inter-domain
        - ASes participate in an inter-domain routing protocol that establishes routes **between domains**
        - Path Vector, e.g., Border Gateway Protocol (BGP)
    
    <aside>
    üß∏ Link State, Distance Vector and Path Vector are Routing algorithm
    
    ![Screen Shot 2021-12-02 at 1.37.05 AM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-12-02_at_1.37.05_AM.png)
    
    </aside>
    

### Link state

- In link state routing,
    - each node maintains it‚Äôs local ‚Äúlink state‚Äù (LS), i.e. a list of its directly attached links and their costs.
    - Each node floods its local link state.
    - Eventually, each node learns the entire network topology.
        
        ![Screen Shot 2021-12-02 at 1.30.51 AM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-12-02_at_1.30.51_AM.png)
        
         
        
- Can use Dijkstra‚Äôs to compute the shortest paths between nodes
    
    In a network topology, each link‚Äôs cost is known to all nodes. Dijkstra‚Äôs algorithm computes the least cost paths from one node (the ‚Äòsource‚Äô) to all other nodes. After¬†*k*¬†iterations, the least cost paths to¬†*k*¬†destinations are known.
    
    - Example
        
        ![Screen Shot 2021-12-02 at 1.33.25 AM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-12-02_at_1.33.25_AM.png)
        
    - Time Complexity
        - n(n+1)/2 comparisons: O(n2) complexity
        - more efficient implementations possible: O(nlogn)
    - Message complexity
        - each router must broadcast its link state information to other n routers
        - efficient (and interesting!) broadcast algorithms: O(n) link crossings to disseminate a broadcast message from one source
        - each router‚Äôs message crosses O(n) links: overall message complexity: O(n2)
    - Oscillations possible
        - When link costs depend on traffic volume, route oscillations possible
        - Example
            
            ![Screen Shot 2021-12-02 at 1.35.07 AM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-12-02_at_1.35.07_AM.png)
            

### Distance vector

In distance vector routing, each router maintains its shortest distance to every destination via each of its neighbours.

First each router initializes its distance table based on its immediate neighbors and link costs. Then each router sends its distance vector (i.e. its ‚Äòshortest path‚Äô to every other router) to its immediate neighbors, which is then processed. This is repeated and converges to the set of shortest paths.

- Based on **Bellman-Ford** (BF) equation (dynamic programming)
- Example
    
    ![Screen Shot 2021-12-02 at 2.10.22 AM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-12-02_at_2.10.22_AM.png)
    
- Distance vector algorithm
    
    each node:
    
    - **wait** for (change in local link cost or DV from neighbor)
    - **recompute** DV estimates using DV received from neighbor
    - if DV to any destination has changed, **notify** neighbors
- Problems with Distance Vector
    - Convergence is the time during which all routers come to an agreement about the best paths through the internetwork
    - Example
        
        ![Screen Shot 2021-12-02 at 2.15.26 AM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-12-02_at_2.15.26_AM.png)
        
        It will eventually converge to 61.(C to A via B will be 1 + 60 = 61.) Because of the problem noted in this picture, it takes several rounds because of the incorrect paths caused by the loops propagating through the DV announcements. This is showing you the partial behaviour. Notice the costs with red circles incrementing by 1, 5->6->7->8 ....
        
    - **Poisoned Reverse Rule**
        - The Poisoned Reverse rule is a rule to avoid ‚Äòcounting to infinity‚Äô. If a router¬†*A*¬†routes via¬†*B*¬†to get to¬†*C*, then¬†*A*¬†tells¬†*B*¬†its distance to¬†*C*¬†is infinite.
        - Example
            
            ![Screen Shot 2021-12-02 at 2.17.09 AM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-12-02_at_2.17.09_AM.png)
            
- Message complexity
    - exchange between neighbors
    - convergence time varies
- speed of convergence
    - may have routing loops
    - count-to-infinity problem

## ICMP: The Internet Control Message Protocol

The Internet Control Message Protocol is a protocol used by hosts and routers to communicate network level information. It works above the IP layer. An ICMP packet contains a type and a code corresponding to different messages plus IP header and first 8 bytes of IP datagram payload causing error.

![Screen Shot 2021-12-02 at 2.28.48 AM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-12-02_at_2.28.48_AM.png)

# Week9 - Data link Layer

---

## Introduction

The link layer has the responsibility of transferring datagrams from one node to another physically adjacent node over a link.

- Datagrams are transferred by different link protocols over different links.
    - e.g. WiFi on first link, Ethernet on next link
- Each link protocol provides a different service.
    - e.g. may or may not provide reliable data transfer over link
    

The **link layer service** provides

- Framing, link access
    - encapsulate datagram into frame, adding header, trailer
    - channel access if shared medium
- Reliable delivery between adjacent nodes
    - wireless links: high error rates
- Flow control
    - Controlling flow between adjacent sending and receiving nodes
- Error detection and correction
    - Receiver detects and corrects bit errors without resorting to retransmission
- Half duplex and full duplex
    - With half duplex, nodes at both ends of link can transmit, but not at same time
    

*Where is the link layer implemented?*

The link layer is implemented in a network interface card (NIC) or on a chip in each and every host. It is implemented as a combination of software and hardware.

![Screen Shot 2021-12-02 at 2.49.07 AM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-12-02_at_2.49.07_AM.png)

## Error detection, correction

### **Parity**

A method of error detection is to add a parity bit every¬†*d*¬†bits. On the receiver side, the number of bits in every block of size¬†*d*¬†is counted and compared with the adjacent parity bit.

This method can only detect when an even number of bits gets flipped, and even then it can only detect errors, not correct them.

The cost of this method is one extra bit for every¬†*d*¬†bits.

![Screen Shot 2021-12-02 at 2.59.36 AM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-12-02_at_2.59.36_AM.png)

### **Two Dimensional Parity**

Rather than just computing parity every¬†*d*¬†bits, we can compute a parity bit for every set of¬†*n*¬†‚Äòcolumns‚Äô too.

This method can detect 1, 2, 3 and some 4 bit errors. It can also correct single bit errors.

![Screen Shot 2021-12-02 at 3.00.04 AM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-12-02_at_3.00.04_AM.png)

### Cyclic Redundancy Check (CRC)

- Goal: choose r CRC bits, R, such that <D,R> exactly divisible by G (mod 2)
‚Ä¢ receiver knows G, divides <D,R> by G. If non-zero remainder: error detected!
‚Ä¢ can detect all burst errors less than r+1 bits
‚Ä¢ widely used in practice (Ethernet, 802.11 WiFi)
    
    ![Screen Shot 2021-12-02 at 3.13.33 AM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-12-02_at_3.13.33_AM.png)
    

- Example
    
    ![Screen Shot 2021-12-02 at 3.13.00 AM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-12-02_at_3.13.00_AM.png)
    
    <aside>
    üß∏ Summary
    - Internet checksums -> can detect errors but can‚Äôt tell where -> can‚Äôt correct either
    - Two-dimensional parity -> can respectively correct any bit errors (sure can detect as well)
    - Cyclic redundancy check (CRC) -> can detect bit errors up to R bits but can‚Äôt tell where -> can‚Äôt correct either
    
    </aside>
    

## Multiple access protocols (MAC)

There are two types of links: 1) **point-to-point** link like between Ethernet switch, host 2) **broadcast** (shared wire or medium) like wireless LAN, 4G/5G. satellite

broadcast need **Multiple access protocols**

A multiple access protocol is a distributed algorithm that determines how nodes share channels, i.e. it determines when nodes can transmit. Communication about channel sharing must use the channel itself.

- Given a single shared broadcast channel, if two or more simultaneous transmissions by nodes occur, then interference occurs. If a node receives two or more signals at the same time, then a **collision** occurs.
- An **ideal** MAC should
    
    Given MAC of rate¬†*R*¬†bps, we want
    
    1. When one node wants to transmit, it can send at rate¬†*R*
    2. When¬†*M*¬†nodes want to transmit, each can send at average rate¬†*R*/*M*
    3. Full decentralisation, i.e. no special node to coordinate transmissions and no synchronisation of clocks
    4. Simple
    
- There are three broad classes of multiple access protocols
    - **Channel partitioning**
        - **Divide** a channel into smaller pieces (i.e. time slots, frequency, code)
        - Allocate pieces to nodes for exclusive use
        - There are two Channel partitioning MAC protocols
            - **TDMA**: time division multiple access
                
                ![Screen Shot 2021-12-04 at 3.20.33 PM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-12-04_at_3.20.33_PM.png)
                
            - **FDMA**: frequency division multiple access
                
                ![Screen Shot 2021-12-04 at 3.20.58 PM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-12-04_at_3.20.58_PM.png)
                
            - Does channel partitioning satisfy ideal properties? (See "**ideal** MAC" above)
                
                No! 
                
                Only 4 is satisfied
                
                For 1, no-matter we using tdm or fdm, they are allocating n slots or n frequency bands.
                Note that 2 is satisfied if M=N (no of nodes on the network) However, more generally for M < N, 2 is not satisfied.
                
                For 3, tdm requires some clock and slots; fdm need some aspects of centrlization with the allocation.
                
    - **Random access**
        - A channel is **not divided** and **allows for collisions**
        - A channel can **recover from collisions**
        - Random access MAC protocol specifies:
        ‚Ä¢ how to detect collisions
        ‚Ä¢ how to recover from collisions (e.g., via delayed retransmissions)
        - Examples of random-access MAC protocols:
        ‚Ä¢ ALOHA, slotted ALOHA
        ‚Ä¢ CSMA, CSMA/CD, CSMA/CA
        - We will study all of them detailed (See below)
            - Pure ALOHA ‚Äî‚Äîimprove‚Äî‚Äî> Slotted ALOHA
    - **Taking turns**
        - Nodes take turns, but nodes with more to send can take longer turns
        - look for best of both "channel partitioning" & "random access"
        - **Polling**
            - **captain** node ‚Äúinvites‚Äù other nodes to transmit in turn
            - typically used with ‚Äúdumb‚Äù devices
            - Some concerns include the polling overhead, latency and having a single point of failure (captain)
                
                ![Screen Shot 2021-12-04 at 4.18.22 PM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-12-04_at_4.18.22_PM.png)
                
            
        - **Token passing**
            - A **control token** is passed from one node to the next sequentially
            - Some concerns include the token overhead, latency and having a single point of failure (token)
                
                ![Screen Shot 2021-12-04 at 4.21.02 PM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-12-04_at_4.21.02_PM.png)
                
        - Does taking turns satisfy ideal properties?
            
            1, 2 and 4 are satisfied
            (neglect the overheads for polling and token passing)
            
        

### **Slotted ALOHA**

Slotted ALOHA is a random access multiple access protocol.

![Screen Shot 2021-12-04 at 3.44.01 PM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-12-04_at_3.44.01_PM.png)

- Assumptions
    - All frames are the same size
    - Time is divided into equal size slots
    - Nodes can start to transmit only at the beginning of a slot
    - Nodes are synchronised
    - If two or more nodes transmit in a slot, all nodes detect a collision
- Operation
    
    When a node obtains a fresh frame, it transmits in the next slot. If there is no collision, the node can send a new frame in the next slot. If there is a collision, the node retransmits the frame in each subsequent slot with **probability¬†*p***¬†until success.
    
- Pros
    - single active node can continuously transmit at **full rate of channel**
    - **highly decentralized**: only slots in nodes need to be in sync
    - simple
- Cons
    - **collisions**, **wasting (idle) slots**
    - nodes may be able to detect collision in less than time to transmit packet
    - **clock synchronization**
- efficiency
    
    Slotted ALOHA is not that efficient, as in the long run, only a fraction of slots are successful in transmitting frames. At best, the channel is used for useful transmissions **only 37%** of the time.
    
- Pure ALOHA (old version)
    - unslotted Aloha: simpler, no synchronization
    - collision probability increases with no synchronization:
    - **pure Aloha efficiency: 18% ! (only half)**
        
        ![Screen Shot 2021-12-04 at 3.46.08 PM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-12-04_at_3.46.08_PM.png)
        

### CSMA (**Carrier Sense Multiple Access)**

- **simple CSMA**: listen before transmit:
    - if channel sensed idle: transmit entire frame
    - if channel sensed busy: defer transmission
    - *human analogy: don‚Äôt interrupt others*
    - In CSMA, collisions can still occur due to propagation delay. Propagation delay means two nodes may not hear each other‚Äôs transmission. If a collision occurs, the entire frame‚Äôs transmission time is wasted.
        
        ![Screen Shot 2021-12-04 at 4.02.15 PM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-12-04_at_4.02.15_PM.png)
        
- **CSMA/CD**: CSMA **with collision detection**
    - collisions detected within short time
    - **colliding transmissions aborted, reducing channel wastage**
    - collision detection easy in wired, difficult with wireless (Why? Since in wired is more easy to detect collision in physical.)
    - *human analogy: the polite conversationalist*
    - CSMA/CD reduces the amount of time wasted in collisions ‚Äî> ransmission aborted on collision detection
        
        ![Screen Shot 2021-12-04 at 4.03.13 PM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-12-04_at_4.03.13_PM.png)
        
    - Ethernet CSMA/CD algorithm (**Collision Detection**)
        
        For ethernet, the collision detection algorithm is as follows *(NIC = Network Interface Card)*
        
        1. The NIC receives datagram from the network layer and creates a frame
        2. If the NIC senses a channel is idle, it starts a frame transmission. If the NIC senses channel is busy, it waits until the channel is idle, then transmits
        3. If the NIC transmits the entire frame without detecting another transmission, the NIC is done
        4. If the NIC detects another transmission while transmitting, it aborts and sends a jam signal
        5. After aborting, **the NIC enters binary (exponential) backoff**
            - After¬†*m*th collision, the NIC chooses a random¬†*k*¬†from¬†{0,1,2,‚Ä¶,2*m*‚àí1}
            - The NIC waits¬†*k*‚ãÖ512¬†bit times and returns to step 2
            - The backoff interval increases as the number of collisions increase
    - Efficiency
        
        better performance than ALOHA: and simple, cheap, decentralized!
        
        ![Screen Shot 2021-12-04 at 4.06.20 PM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-12-04_at_4.06.20_PM.png)
        
    - Does CSMA/CD satisfy ideal properties ?
        
        1, 3 and 4 are satisfied
        2 is not satisfied as bandwidth is wasted due to collisions when multiple nodes are transmitting (neglect the overheads for channel sensing)
        

## LANs

### **Addressing**

- MAC address
    - A MAC (or LAN/physical/ethernet) address is a 48 bit address built in to NIC ROM, also sometimes software settable.
    - It is in a hexadecimal format.
    - MAC address allocation is administered by IEEE.
    - The namespace of a MAC address is flat, compared to an IP address which is hierarchical. MAC addresses are used to get packets between interfaces on the same network.
- MAC address VS IP address
    
    ![Screen Shot 2021-12-04 at 4.53.28 PM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-12-04_at_4.53.28_PM.png)
    
    - MAC addresses (used in link-layer)
        - Hard-coded in read-only memory when adapter is built
        - Flat name space of 48 bits (e.g., 00-0E-9B-6E-49-76)
        - Portable, and can stay the same as the host moves
        - Used to get packet between interfaces on same network  ‚Äî> to that subnet (completely independent)
        - analogy: like TFN (SSN)
    - IP addresses
        - learned dynamically
        - Hierarchical name space of 32 bits (e.g., 12.178.66.9)
        - Not portable, and depends on where the host is attached
        - Used to get a packet to destination IP subnet ‚Äî>  within that subnet (hierarchy)
        - analogy: like postal address

<aside>
üß∏ Summary

![Screen Shot 2021-12-04 at 4.55.29 PM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-12-04_at_4.55.29_PM.png)

</aside>

*how to determine interface‚Äôs MAC address, knowing its IP address?*

### ARP: address resolution protocol

An¬†**ARP table**¬†is a mapping from an IP address to a MAC address with an associated TTL. Each LAN contains an ARP table.

- IP/MAC address mappings for some LAN nodes:
< IP address; MAC address; TTL>
- TTL (Time To Live): time after which address mapping will be forgotten (typically 20 min)
- Example (Routing to another subnet: addressing)
    
    ‚Äî> sending a datagram from A to B via R
    
    ![Screen Shot 2021-12-04 at 5.00.29 PM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-12-04_at_5.00.29_PM.png)
    
    1. A creates IP datagram with IP source A, destination B
    2. A creates link-layer frame containing A-to-B IP datagram
    ‚Ä¢ R's MAC address is frame‚Äôs destination
        
        ![Screen Shot 2021-12-04 at 5.02.01 PM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-12-04_at_5.02.01_PM.png)
        
    3. frame sent from A to R
        - Here are two questions
            - how A knows (first hop router) **R‚Äôs IP address ?**
                
                DHCP!
                
            - How does A knows **R‚Äôs MAC address ?**
                
                ARP!
                
            
    4. frame received at R, datagram removed, passed up to IP
        
        ![Screen Shot 2021-12-04 at 5.02.55 PM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-12-04_at_5.02.55_PM.png)
        
    5. R determines outgoing interface, passes datagram with IP source A, destination B to link layer
    6. R creates link-layer frame containing A-to-B IP datagram. Frame destination address: B's MAC address
        
        ![Screen Shot 2021-12-04 at 5.07.35 PM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-12-04_at_5.07.35_PM.png)
        
    7. transmits link-layer frame
        
        ![Screen Shot 2021-12-04 at 5.10.23 PM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-12-04_at_5.10.23_PM.png)
        
    8. B receives frame, extracts IP datagram destination
    9. B passes datagram up protocol stack to IP
        
        ![Screen Shot 2021-12-04 at 5.10.48 PM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-12-04_at_5.10.48_PM.png)
        
- Security Issues: ARP Cache Poisoning
    - hacker can pretend to be the router
        
        ![Screen Shot 2021-12-04 at 5.12.22 PM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-12-04_at_5.12.22_PM.png)
        
    - There are solutions like using ARP monitoring tools such as ARPWatch.

### **Ethernet**

Ethernet is a dominant wired LAN technology. Previously it used a¬†"*bus"*¬†for transmission, but now more commonly uses a¬†*star*¬†topology which contains an active "switch" in the center with each ‚Äòspoke‚Äô running a seperate ethernet protocol.

![Screen Shot 2021-12-04 at 5.52.42 PM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-12-04_at_5.52.42_PM.png)

- Ethernet frame structure
    
    ![Screen Shot 2021-12-04 at 6.09.16 PM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-12-04_at_6.09.16_PM.png)
    
    - preamble:
        - used to synchronize receiver, sender clock rates
        - 7 bytes of 10101010 followed by one byte of 10101011
- Ethernet: unreliable, connectionless
    - **Connectionless**
        - There is no handshaking between sending and receiving NICs
    - **Unreliable**
        - A receiving NIC does not send ACKs or NACKs to the sending NIC
    - Ethernet‚Äôs MAC protocol is **unslotted** CSMA/CD with binary backoff.

### **Switches**

A switch is a link layer device that stores and forwards ethernet frames. It examines incoming an frame‚Äôs MAC address, and selectively forwards it to one or more outgoing links.

Switches are¬†**transparent**¬†in the sense that hosts are unaware of their prescence. Switches also don‚Äôt need to be configured.

- **Switch: multiple simultaneous transmissions**
    
    Hosts have a dedicated, direct connection to a switch. Switches buffer packets and runs at full duplex.  **switching**: A-to-A‚Äô and B-to-B‚Äôcan transmit simultaneously, without collisions. But A-to-A‚Äô and C to A‚Äô can not happen simultaneously.
    

![Screen Shot 2021-12-04 at 6.27.30 PM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-12-04_at_6.27.30_PM.png)

![Screen Shot 2021-12-04 at 6.27.47 PM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-12-04_at_6.27.47_PM.png)

- **Switch forwarding table**
    - each switch has a switch table, each entry:(MAC address of host, interface to reach host,
    time stamp)
    - looks like a routing table!
- **Switch: self-learning**
    
    Switches are¬†***self learning***¬†in the sense that they learn which hosts can be reached through which interfaces. When a frame is received, the switch learns the location of the sender and records the sender/location pair in it‚Äôs switch table.
    

![Screen Shot 2021-12-04 at 6.29.58 PM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-12-04_at_6.29.58_PM.png)

- **Switch: frame filtering/forwarding**
    
    when frame received at switch:
    
    1. record incoming link, MAC address of sending host
    2. index switch table using MAC destination address
    3. if entry found for destination ‚Äî> this found means found in forwarding table
    then {
    if destination on segment from which frame arrived then drop frame
    else forward frame on interface indicated by entry
    }
    else flood /* forward on all interfaces except arriving interface */
    
    *flood ‚Üí destination A location known: selectively send on just one link ‚Üí like broadcast* 
    

- **Switches vs. Routers**
    - both are store-and-forward:
        - routers: network-layer devices (examine network-layer headers)
        - switches: link-layer devices (examine linklayer headers)
    - both have forwarding tables:
        - routers: compute tables using routing algorithms, IP addresses
        - switches: learn forwarding table using flooding, learning, MAC addresses

![Screen Shot 2021-12-04 at 6.37.53 PM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-12-04_at_6.37.53_PM.png)

- **Security Issues**
    
    Switch Poisoning: Attacker fills up switch table with bogus entries by sending large # of frames with bogus source MAC addresses
    

### Synthesis: a day in the life of a web request

scenario: student attaches laptop to campus network, requests/receives [www.google.com](http://www.google.com/)

![Screen Shot 2021-12-06 at 11.05.16 AM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-12-06_at_11.05.16_AM.png)

1. connecting to the Internet
    1. connecting laptop needs to get its own IP address, addr of first-hop router, addr of DNS server: **use DHCP**
    2. DHCP request encapsulated in UDP, encapsulated in IP, encapsulated in 802.3 Ethernet
    3. Ethernet frame broadcast (dest: FFFFFFFFFFFF) on LAN, received at router running DHCP server
    4. Ethernet demuxed to IP demuxed, UDP demuxed to DHCP (**Demuxing is an abbreviation of¬†**demultiplexing***)
    5. DHCP server formulates DHCP ACK containing client‚Äôs IP address, IP address of first-hop router for client, name & IP address of DNS server
    6. encapsulation at DHCP server, frame forwarded (switch learning) through LAN, demultiplexing at client
    7. DHCP client receives DHCP ACK reply
    
    ‚Üí *Client now has IP address, knows name & addr of DNS server, IP address of its first-hop router*
    
    ![Screen Shot 2021-12-06 at 11.14.55 AM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-12-06_at_11.14.55_AM.png)
    
2. ARP (before DNS, before HTTP)
    1. before sending HTTP request, need IP address of [www.google.com](http://www.google.com/): DNS
    2. DNS query created, encapsulated in UDP, encapsulated in IP, encapsulated in Eth. To send frame to router, need MAC address of router interface: ARP
    3. ARP query broadcast, received by router, which replies with ARP reply giving MAC
    address of router interface
    
    ‚Üí *client now knows MAC address of first hop router, so can now send frame containing DNS query*
    
    ![Screen Shot 2021-12-06 at 11.18.19 AM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-12-06_at_11.18.19_AM.png)
    
3. using DNS
    1. IP datagram containing DNS query forwarded via LAN switch from client to 1st hop router
    2. IP datagram forwarded from campus network into Comcast network, routed (tables created by RIP, OSPF, IS-IS and/or BGP routing protocols) to DNS server
    3. demuxed to DNS
    4. DNS replies to client with IP address of [www.google.com](http://www.google.com/)
    
    ‚Üí *client now knows IP address of google*
    
    ![Screen Shot 2021-12-06 at 11.21.01 AM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-12-06_at_11.21.01_AM.png)
    
4. TCP connection carrying HTTP
    1. to send HTTP request, client first opens TCP socket to web server
    2. TCP SYN segment (step 1 in TCP 3-way handshake) interdomain routed to web server
    3. web server responds with TCP SYNACK (step 2 in TCP 3-way handshake)
    
    *‚Üí TCP connection established!*
    
    ![Screen Shot 2021-12-06 at 11.22.44 AM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-12-06_at_11.22.44_AM.png)
    
5. HTTP request/reply
    1. HTTP request sent into TCP socket
    2. IP datagram containing HTTP request routed to [www.google.com](http://www.google.com/)
    3. web server responds with HTTP reply (containing web page)
    4. IP datagram containing HTTP reply routed back to client
    
    *‚Üí web page finally (!!!) displayed*
    
    ![Screen Shot 2021-12-06 at 11.24.29 AM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-12-06_at_11.24.29_AM.png)
    

### Wireless Networks

- Introduction (Elements of a wireless network)
    - **wireless hosts**: e.g. laptop, smartphone, IoT
        
        may be stationary (non-mobile) or mobile, wireless does not always mean mobility!
        
    - **base station**: typically connected to wired network, relay - responsible for sending packets
    between wired network and wireless host(s) in its ‚Äúarea‚Äù e.g., cell towers, 802.11 access points.
    - **wireless link:** typically used to connect mobile(s) to base station, also used as backbone link. Multiple access protocol coordinates link access. Has various transmission rates and
    distances, frequency bands.
    - **infrastructure mode**: base station connects mobiles into wired network. handoff: mobile changes base station providing connection into wired network.
        
        ![Screen Shot 2021-12-05 at 12.14.26 AM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-12-05_at_12.14.26_AM.png)
        
    - **ad hoc mode**: no base stations, nodes can only transmit to other nodes within link coverage. nodes organize themselves into a network: route among themselves.
        
        ![Screen Shot 2021-12-05 at 12.14.48 AM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-12-05_at_12.14.48_AM.png)
        

<aside>
üß∏ Summary

![Screen Shot 2021-12-05 at 12.16.50 AM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-12-05_at_12.16.50_AM.png)

</aside>

- **Characteristics of selected wireless links**
    - **Wireless link characteristics (1)**
        - decreased signal strength
        - interference from other sources
        - multipath propagation: ‚Üí **Multipath Effects ‚Üí Self-interference**
            
            Signals bounce off surface and interfere (constructive or destructive) with one another
            
            ![Screen Shot 2021-12-05 at 12.19.44 AM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-12-05_at_12.19.44_AM.png)
            
    - **Wireless link characteristics (2)**
        - **SNR**: signal-to-noise ratio: larger SNR ‚Äì easier to extract signal from
        noise (a ‚Äúgood thing‚Äù)
        - **SNR vs. BER tradeoff**
            
            **Note that BER is bit error rate, of course we want as low as possible so...*
            
            *and QAM256, QAM16, BPSK just different physical layer.*
            
            ![Screen Shot 2021-12-05 at 12.28.34 AM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-12-05_at_12.28.34_AM.png)
            
            - **given physical layer**: increase power -> increase SNR->decrease BER
                
                Here incresing power ‚Üí may exhaust the battery 
                
                                             ‚Üí and government is limit "how loud can you shout(transmit)"
                
            - **given SNR**: choose physical layer that meets BER requirement, giving highest
            throughput
                - SNR may change with mobility: dynamically adapt physical layer (modulation technique, rate)
    - **Wireless link characteristics (3)**
        
        Multiple wireless senders, receivers create additional problems like...
        
        - **Hidden terminal problem**
            
            ![Screen Shot 2021-12-05 at 12.32.59 AM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-12-05_at_12.32.59_AM.png)
            
        - **Signal attenuation**
            
            ![Screen Shot 2021-12-05 at 12.33.26 AM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-12-05_at_12.33.26_AM.png)
            

### IEEE 802.11 wireless LANs (‚ÄúWi-Fi‚Äù)

- **WiFi**
    
    There are multiple types of WiFi protocols including 802.11b, 802.11a, 802.11g and 802.11n. They all have minor differences including their spectrum/range and bit rate.
    
- **802.11 LAN Architecture**
    
    ![Screen Shot 2021-12-05 at 12.49.25 AM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-12-05_at_12.49.25_AM.png)
    
    - A wireless host communicates with a base station or access point (AP).
    - **Basic Service Set (BSS**) (aka ‚Äúcell‚Äù) in infrastructure mode contains:
        - wireless hosts
        - access point (AP): base station
        - ad hoc mode: hosts only
    - 802.11: Channels, association
        
        The 802.11 protocol spectrum divided into channels at different frequencies. The AP admin chooses the frequency for their AP, but this may interfere with neighboring APs.
        
        A host must associate with an AP, which involves scanning channels(See below for details), selecting an AP, possibly performing authentication and typically running DHCP to get an IP address for the APs subnet.
        
    - 802.11: passive/active scanning
        - **passive scanning**:
        (1) beacon frames sent from APs
        (2) association Request frame sent: H1 to selected AP
        (3) association Response frame sent from selected AP to H1
            
            ![Screen Shot 2021-12-05 at 12.48.46 AM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-12-05_at_12.48.46_AM.png)
            
        - **active scanning**:
        (1) Probe Request frame broadcast from H1
        (2) Probe Response frames sent from APs
        (3) Association Request frame sent: H1 to selected AP
        (4) Association Response frame sent from selected AP to H1
            
            ![Screen Shot 2021-12-05 at 12.49.03 AM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-12-05_at_12.49.03_AM.png)
            
- **IEEE 802.11: multiple access**
    - Remember the problem we mentioned before, we need to deal with collision. But unlike before we use CSMA/CD to detect collision, it's too hard to detect collision in wireless network (Since hidden terminal, fading etc.) We now use CSMA/CA to avoid collision.
    - **IEEE 802.11 MAC Protocol: CSMA/CA**
        
        ![Screen Shot 2021-12-05 at 1.09.12 AM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-12-05_at_1.09.12_AM.png)
        
        - **sender**
            - if sense *channel idle* for DIFS then transmit entire frame (no CD)
            - if sense *channel busy* then
                - start random backoff time
                - timer counts down while channel idle
                - transmit when timer expires
                - if no ACK, increase random backoff interval, repeat 2
        - **receiver**
            - if frame received OK ‚Üí return ACK after SIFS (ACK needed due to hidden
            terminal problem)
        - About **Avoiding collisions**
            - idea is sender ‚Äú**reserves**‚Äù channel use for data frames using small reservation
            packets
            - sender first transmits small request-to-send (RTS) packet to BS using CSMA
                - RTSs may still collide with each other (but they‚Äôre short)
            - BS broadcasts clear-to-send CTS in response to RTS
            - CTS heard by all nodes
                - sender transmits data frame
                - other stations defer transmissions
            - Summary
                
                ### **802.11 MAC Protocol**
                
                - 802.11 uses CSMA with collision avoidance (CSMA/CA) as its random access protocol. This performs the same way as CSMA/CD, except it has collition avoidance rather than collision detection. This means that once a station begins to transmit a frame, it transmits the frame in its entirety.
                - If more than one station senses that a channel is busy, they all immediately enter random backoff, hopefully choosing different backoff values. The first station to come out of random backoff is the ‚Äòwinner‚Äô and starts transmitting on the channel. All other ‚Äòlosing‚Äô stations now sense that the channel is in use, and refrain from transmitting.
                
                ### **RTS & CTS**
                
                - To avoid the ‚Äòhidden terminal‚Äô problem, 802.11 employs a strategy known as Request to Send and Clear to Send (RTS/CTS). When a station wants to send data, it first sends an RTS frame indicating the total time required to transmit the data and the ACK frame. A CTS frame is then broadcasted from the access point indicating that the sender is clear to begin transmission. All other stations will hear this CTS frame and will refrain from transmitting.

# Week10 - Network Security

---

## What is network security?

we want ‚Üí confidentiality, authentication, message integrity, access and availability, etc.

bad things ‚Üí eavesdrop, impersonation, hijacking, denial of service, etc.

## Principles of cryptography

- **Cryptography**
    
    Let
    
    - *m*¬†be a plaintext message
    - *K_A*(*m*)¬†be **ciphertext**, encrypted with key¬†*K_A,*  **encryption key**
- **Symmetric key cryptography**: Users share the same (symmetric) encryption key¬†*K_S*.
- Two types of symmetric ciphers
    - **Stream Ciphers**
        
        ![Screen Shot 2021-12-05 at 1.49.38 AM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-12-05_at_1.49.38_AM.png)
        
        Stream ciphers encrypt **one bit at time**. Each bit of the keystream is combined with a bit of plaintext to get a bit of ciphertext. **RC4** is a popular stream cipher
        
        We have
        
        - *m*(*i*)¬†being the¬†*i*th bit of the message
        - *ks*(*i*)¬†being the¬†*i*th bit of the keystream
        - *c*(*i*)¬†being the¬†*i*th bit of the cyphertext
        
        Then
        
        - *c*(*i*) = *ks*(*i*)‚äï *m*(*i*)
        - *m*(*i*) = *ks*(*i*)‚äï *c*(*i*)
    - **Block Ciphers**
        
        ![Screen Shot 2021-12-05 at 1.50.12 AM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-12-05_at_1.50.12_AM.png)
        
        Block ciphers break plaintext message in to **equal sized blocks**. Each block is encrypted as a unit. Ciphertext is processed as¬†*k*¬†bit blocks. A one to one mapping is used to map a¬†*k*¬†bit block of plaintext to a¬†*k*¬†bit block of ciphertext.
        
- **DES: Data Encryption Standard**
    
    ![Screen Shot 2021-12-05 at 1.50.56 AM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-12-05_at_1.50.56_AM.png)
    
    - Data Encryption Standard (DES) is a US encryption standard that uses a 56 bit symmetric key, and a 64 bit plaintext input. ‚Üí very complex
- **AES: Advanced Encryption Standard**
    - Advanced Encryption Standard (AES) is a symmetric key NIST standard that replaces DES. It processes data in 128 bit blocks using 128, 192 or 256 bit keys. ‚Üí very very complex
    - brute force decryption (try each key) taking 1 sec on DES, takes 149 trillion years for AES.

*cipher block is good but if input block repeated, will produce same cipher text... so how to fix this?*

- **Cipher Block Chaining (CBC)**
    - Use random numbers: XOR ith input block, m(i) and random number r(i) and
    apply block-cipher encryption algorithm
    
    *But we need to transmit twice as many bits for the random numbers that we're using*
    
    *So we designed CBC :)*
    
    - cipher block chaining: send only one random value alongwith the very first
    message block, and then have the sender and receiver use the computed cipher block in place of the subsequent random number
        
        Initialization vector (IV): random block = c(0), IV does not have to be secret.
        
        ![Screen Shot 2021-12-05 at 2.01.03 AM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-12-05_at_2.01.03_AM.png)
        

*Symmetric key cryptography is great but how to agree on key in first place (particularly if never
‚Äúmet‚Äù)*

- **Public Key Cryptography**
    - sender, receiver do not share secret key
        - **public encryption key** known to all
        - **private decryption key** known only to receiver
    - public key cryptography revolutionized 2000-year-old (previously only symmetric
    key) cryptography!
    - **Public Key Encryption Algorithms**
        
        ![Screen Shot 2021-12-05 at 2.13.31 AM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-12-05_at_2.13.31_AM.png)
        
    - **RSA (Rivest, Shamir, Adelson algorithm)**
        
        To create a public/private key pair
        
        1. Choose two large prime numbers¬†*p*,¬†*q*
        2. Compute¬†*n*=*pq*,¬†*z*=(*p*‚àí1)(*q*‚àí1)
        3. Choose¬†*e*¬†(with¬†*e*<*n*) that has no common factors with¬†*z*¬†(i.e.¬†*e*¬†and¬†*z*¬†are relatively prime
        4. Choose¬†*d*¬†such that¬†*ed*‚àí1¬†is exactly divisible by¬†*z*¬†(i.e.¬†*ed* mod *z* = 1)
        
        At this point the public key¬†(*n*,*e*)¬†and private key¬†(*n*,*d*).
        
        ![Screen Shot 2021-12-05 at 2.16.57 AM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-12-05_at_2.16.57_AM.png)
        
        - RSA: another important property
            
            ![Screen Shot 2021-12-05 at 2.17.46 AM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-12-05_at_2.17.46_AM.png)
            
        - Why is RSA secure?
            - suppose you know Bob‚Äôs public key (n,e). How hard is it to determine d?
            - essentially need to find factors of n without knowing the two factors p and q
            ‚Ä¢ fact: factoring a big number is hard

<aside>
üß∏ Summary

However, since exponentiation in RSA is computationally intensive (public key cryptography is too slow) ...DES is at least 100 times faster than RSA

So normally we use public key crypto to establish secure connection firstly, then establish second key ‚Äì symmetric session key ‚Äì for encrypting data.

</aside>

## Authentication

nonce: number (R) used only once-in-a-lifetime

![Screen Shot 2021-12-05 at 2.28.19 AM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-12-05_at_2.28.19_AM.png)

But Authentication: ap5.0 ‚Äì there‚Äôs still a flaw!

![Screen Shot 2021-12-05 at 2.29.01 AM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-12-05_at_2.29.01_AM.png)

The problem here is we **need for certified public keys**! We will fix this later

## Message integrity

- **Confidentiality vs Integrity**
    
    **Confidentiality**¬†refers to when a message is kept private and secret.¬†**Integrity**¬†refers to the protection against message tampering. Encryption alone may not guarantee integrity. Both confidentiality and integrity are needed for security.
    
- **Digital Signatures**
    
    A digital signature is a cryptographic technique analogous to hand written signatures. 
    
    ![Screen Shot 2021-12-05 at 2.44.36 AM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-12-05_at_2.44.36_AM.png)
    
- **Message Digests**
    
    It is computationally expensive to public key encrypt long messages. A message digest is a fixed length, easy to compute digital footprint. A hash function¬†*H()*¬†is applied to¬†*m*¬†to get a fixed sized message digest¬†*H*(*m*).
    
    The hash function¬†*H*¬†has the following properties
    
    - Many to one
    - Produces a fixed sized message digest
    - Given a message digest¬†*x*, it is computationally infeasible to find¬†*m*¬†such that¬†*x = H*(*m*)
    
    Some common hash function algorithms are MD5, SHA-1, SHA-2 and SHA-3.
    
    Example: ‚Üí Bob applies a hash function to m and encrypts the result with his private key
    
    ![Screen Shot 2021-12-05 at 2.48.40 AM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-12-05_at_2.48.40_AM.png)
    

*Now we can fix the "Need for certified public keys" before*

- **Public key Certification Authorities (CA)**
    - **certification authority (CA)**: binds public key to particular entity, E
    - entity (person, website, router) registers its public key with CE provides ‚Äúproof of identity‚Äù to CA
        - CA creates certificate binding identity E to E‚Äôs public key
        - certificate containing E‚Äôs public key digitally signed by CA's private key: CA says ‚Äúthis is E‚Äôs public key‚Äù
            
            ![Screen Shot 2021-12-05 at 2.59.39 AM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-12-05_at_2.59.39_AM.png)
            
    - Public-Key Infrastructure (PKI)
        - Certificates and certification authorities
        - Often considered ‚Äúheavy‚Äù

## **Securing Email**

- Secure e-mail: **confidentiality**
    
    ![Screen Shot 2021-12-05 at 3.06.52 AM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-12-05_at_3.06.52_AM.png)
    
- Secure e-mail: **integrity, authentication**
    
    ![Screen Shot 2021-12-05 at 3.07.04 AM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-12-05_at_3.07.04_AM.png)
    
- Secure e-mail: **confidentiality, integrity, authentication**
    
    ![Screen Shot 2021-12-05 at 3.07.45 AM.png](COMP3331-Computer%20Networks%20and%20Applications%20f598b79143bc4026b17e2e61b315d466/Screen_Shot_2021-12-05_at_3.07.45_AM.png)
    
- **PGP**
    
    PGP is the de-factor standard for email encryption. On installation PGP creates a public, private key pair. There is an option to digitally sign the message, encrypt the message or both. PGP uses MD5 or SHA to compute a message digest and RSA for public key encryption.